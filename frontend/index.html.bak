<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-TL5XD333');</script>
    <!-- End Google Tag Manager -->

    <!-- Essential Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <!-- Primary Meta Tags -->
    <title>Track Athletic Performance & Power Zones | Athlytx</title>
    <meta name="title" content="Track Athletic Performance & Power Zones | Athlytx">
    <meta name="description" content="Track your athletic performance with real-time power zones, heart rate monitoring, and personalized training insights. Connect Strava, Garmin, Oura, and Whoop for data-driven results.">
    <meta name="author" content="Athlytx Team">
    <meta name="language" content="en">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://athlytx.com/">

    <!-- Robots -->
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://athlytx.com/">
    <meta property="og:title" content="Track Athletic Performance & Power Zones | Athlytx">
    <meta property="og:description" content="Real-time power zones, heart rate monitoring, and personalized training insights. Connect your fitness devices for data-driven athletic performance.">
    <meta property="og:image" content="https://athlytx.com/src/images/og-athlytx-dashboard.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Athlytx Dashboard showing power zones, heart rate data, and performance metrics">
    <meta property="og:site_name" content="Athlytx">
    <meta property="og:locale" content="en_US">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@athlytx">
    <meta name="twitter:creator" content="@athlytx">

    <!-- iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Athlytx">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon-180x180.png">

    <!-- Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a1a">
    <link rel="manifest" href="/manifest.json">

    <!-- Microsoft -->
    <meta name="msapplication-TileColor" content="#1a1a1a">
    <meta name="msapplication-TileImage" content="/icons/mstile-144x144.png">

    <!-- Structured Data (JSON-LD) - SoftwareApplication Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "Athlytx",
      "applicationCategory": "HealthApplication",
      "operatingSystem": "Web",
      "description": "Athletic performance tracking platform connecting Strava, Garmin, Oura, and Whoop for comprehensive fitness analytics",
      "url": "https://athlytx.com",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.9",
        "ratingCount": "187"
      },
      "featureList": [
        "Real-time power zone tracking",
        "Heart rate monitoring",
        "Multi-device integration (Strava, Garmin, Oura, Whoop)",
        "AI-powered training insights",
        "Performance analytics",
        "Training readiness scoring"
      ]
    }
    </script>

    <!-- Organization Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "Athlytx",
      "description": "Advanced fitness analytics platform for data-driven athletic performance",
      "url": "https://athlytx.com",
      "logo": "https://athlytx.com/src/images/AthlytxLogo.png",
      "sameAs": [
        "https://twitter.com/athlytx",
        "https://facebook.com/athlytx"
      ]
    }
    </script>

    <!-- FAQ Schema for AI Overview Optimization -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "What is Athlytx?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Athlytx is an advanced fitness analytics platform that integrates data from Strava, Garmin, Oura, and Whoop to provide real-time power zones, heart rate monitoring, and personalized training insights for athletes and coaches."
          }
        },
        {
          "@type": "Question",
          "name": "Which fitness devices does Athlytx support?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Athlytx integrates with Strava for activity tracking, Garmin Connect for comprehensive training metrics, Oura Ring for sleep and recovery data, and Whoop for strain and recovery insights. All device data syncs automatically to your unified dashboard."
          }
        },
        {
          "@type": "Question",
          "name": "What are power zones in athletic training?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Power zones are training intensity ranges based on your functional threshold power (FTP). They help athletes train at specific intensities for optimal performance gains. Athlytx tracks your power zones in real-time across all your cycling and running activities."
          }
        },
        {
          "@type": "Question",
          "name": "How does Athlytx help coaches manage athletes?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Athlytx Elite provides coaches with a professional dashboard to manage multiple athletes, track performance metrics, monitor training load, analyze power zones, and share insights. Coaches can invite athletes and view their real-time training data in one unified platform."
          }
        },
        {
          "@type": "Question",
          "name": "Is Athlytx free to use?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes, Athlytx offers a free plan for athletes to connect their fitness devices and track basic performance metrics. Premium features for advanced analytics and coach functionality are available with paid plans."
          }
        },
        {
          "@type": "Question",
          "name": "How does Athlytx calculate training readiness?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Athlytx calculates training readiness by analyzing multiple data points including heart rate variability (HRV) from Oura or Whoop, recovery metrics, sleep quality, training load, and recent activity strain. This creates a comprehensive readiness score to optimize your training."
          }
        }
      ]
    }
    </script>

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link rel="stylesheet" href="/styles/design-tokens.css">
    <link rel="stylesheet" href="/styles/layout.css">
    <link rel="stylesheet" href="/styles/components.css">
    <link rel="stylesheet" href="/styles/dashboard.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TL5XD333"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <!-- Fixed Header -->
    <header class="main-header">
        <div class="header-container">
            <div class="header-left">
                <img src="https://www.athlytx.com/src/images/AthlytxLogo.png" alt="Athlytx Logo" class="header-logo" crossorigin="anonymous">
                <div class="header-tagline">You earned the data. Now let it earn you results.</div>
            </div>

            <div class="header-right">
                <span id="readinessPill" class="readiness-pill"><i class="fas fa-flag-checkered"></i> Readiness: --</span>
                <button onclick="refreshAllData()" class="refresh-btn"><i class="fas fa-sync-alt"></i> Refresh</button>
                <button onclick="clearAllData()" class="refresh-btn"><i class="fas fa-trash-alt"></i> Clear</button>
                <a href="/about.html" class="nav-link"><i class="fas fa-book"></i> About</a>
                <a href="/privacy.html" class="nav-link"><i class="fas fa-lock"></i> Privacy</a>
                <a href="/access" class="elite-btn">Elite Dashboard ‚Üí</a>
            </div>
        </div>
    </header>

    <div id="dashboard" class="dashboard">
        <div class="container">

            <!-- SCORE HERO WITH FLANKING METRICS -->
            <div class="score-hero-section">
                <div class="score-hero-container">

                    <!-- LEFT METRICS: Recovery & Strain stacked -->
                    <div class="metrics-side-card">
                        <div class="metric-item">
                            <div class="metric-value" id="scoreRecovery">--</div>
                            <div class="metric-label">Recovery</div>
                        </div>
                        <div class="metric-divider"></div>
                        <div class="metric-item">
                            <div class="metric-value" id="scoreLoad">--</div>
                            <div class="metric-label">Strain</div>
                        </div>
                    </div>

                    <!-- CENTER: Athlytx Score -->
                    <div class="score-center">
                        <div class="score-circle-wrapper">
                            <svg class="score-svg" viewBox="0 0 200 200">
                                <circle cx="100" cy="100" r="90" class="score-ring-bg"/>
                                <circle id="scoreProgressCircle" cx="100" cy="100" r="90" class="score-ring-progress"/>
                                <defs>
                                    <linearGradient id="scoreGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                        <stop offset="50%" style="stop-color:#764ba2;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#f093fb;stop-opacity:1" />
                                    </linearGradient>
                                </defs>
                            </svg>
                            <div class="score-content">
                                <div class="score-number" id="athlytxScore">--</div>
                                <div class="score-max">out of 100</div>
                            </div>
                        </div>
                        <div id="scoreStatusContainer" class="score-status-container">
                            <div class="score-status-title" id="scoreStatus">Connect devices</div>
                            <div class="score-insight" id="scoreInsight">Connect your devices to see your score</div>
                        </div>
                    </div>

                    <!-- Readiness Status -->
                    <div class="readiness-status-hero" id="readinessHero">
                        <div class="readiness-icon" id="readinessIcon">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"
                                      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                                <path d="M3.22 12h7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                                <path d="M13.5 8.5l2 2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                                <path d="M13.5 15.5l2-2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                        </div>
                        <div class="readiness-text">
                            <div class="readiness-label">Today's Readiness</div>
                            <div class="readiness-message" id="readinessMessage">Connect your devices to see your status</div>
                        </div>
                    </div>

                    <!-- RIGHT METRICS: Sleep & HRV stacked -->
                    <div class="metrics-side-card">
                        <div class="metric-item">
                            <div class="metric-value" id="scoreSleep">--</div>
                            <div class="metric-label">Sleep</div>
                        </div>
                        <div class="metric-divider"></div>
                        <div class="metric-item">
                            <div class="metric-value" id="scoreHRV">--</div>
                            <div class="metric-label">HRV</div>
                        </div>
                    </div>
                </div>

                <!-- Data Sources Badge -->
                <div class="score-badge-container">
                    <div id="dataSourcesBadge" class="data-sources-badge">
                        <span id="deviceGuidance">Connect devices</span>
                    </div>
                </div>
            </div>

            <!-- Hidden elements -->
            <div style="display: none;">
                <div id="scoreSources"></div>
                <div id="readinessBanner"></div>
            </div>

            <div class="tab-nav-wrapper">
                <div class="tab-scroll-indicator left" id="tabScrollLeft">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M12 4l-8 6 8 6V4z"/>
                    </svg>
                </div>
                <nav class="tab-nav" role="tablist" aria-label="Dashboard sections" id="tabNav">
                    <button class="tab-button active" role="tab" aria-selected="true" aria-controls="connections" data-tab="connections">
                        Connections
                    </button>
                    <button class="tab-button" role="tab" aria-selected="false" aria-controls="overview" data-tab="overview">
                        Overview
                    </button>
                    <button class="tab-button" role="tab" aria-selected="false" aria-controls="garmin" data-tab="garmin">
                        Garmin Data
                    </button>
                    <button class="tab-button" role="tab" aria-selected="false" aria-controls="strava" data-tab="strava">
                        Strava Data
                    </button>
                    <button class="tab-button" role="tab" aria-selected="false" aria-controls="oura" data-tab="oura">
                        Oura Data
                    </button>
                    <button class="tab-button" role="tab" aria-selected="false" aria-controls="whoop" data-tab="whoop">
                        Whoop Data
                    </button>
                    <button class="tab-button" role="tab" aria-selected="false" aria-controls="running" data-tab="running">
                        <i class="fas fa-running"></i> Running
                    </button>
                    <button class="tab-button" role="tab" aria-selected="false" aria-controls="insights" data-tab="insights">
                        AI Insights
                    </button>
                    <button class="tab-button" role="tab" aria-selected="false" aria-controls="contact" data-tab="contact">
                        <i class="fas fa-envelope"></i> Contact
                    </button>
                </nav>
                <div class="tab-scroll-indicator right" id="tabScrollRight">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M8 4v12l8-6-8-6z"/>
                    </svg>
                </div>
            </div>

            <!-- Tab Content Wrapper -->
            <div class="tab-content-wrapper">
                <!-- Connections Tab -->
                <div id="connections" class="tab-panel active" role="tabpanel" aria-labelledby="connections-tab">
                <div class="devices-grid stagger-children">
                    <div class="device-card glass-card stagger-item">
                        <div class="device-header">
                            <div class="device-icon strava">
                                <img src="/src/images/strava.svg" alt="Strava" onerror="this.style.display='none'; this.parentNode.innerHTML='S';">
                            </div>
                            <div class="device-info">
                                <h3>Strava</h3>
                                <p>Activities and performance data</p>
                            </div>
                        </div>
                        <button class="connect-btn btn-strava" onclick="connectDevice('strava')">
                            Connect with Strava
                        </button>
                        <button class="disconnect-btn btn-strava-disconnect" onclick="disconnectDevice('strava')" style="display: none; margin-top: 8px;">
                            Disconnect
                        </button>
                    </div>

                    <div class="device-card glass-card">
                        <div class="device-header">
                            <div class="device-icon oura">
                                <img src="/src/images/oura-logo.jpeg" alt="Oura" onerror="this.style.display='none'; this.parentNode.innerHTML='O';">
                            </div>
                            <div class="device-info">
                                <h3>Oura Ring</h3>
                                <p>Readiness, activity, and sleep insights</p>
                            </div>
                        </div>
                        <button class="connect-btn btn-oura" onclick="connectDevice('oura')">
                            Connect with Oura
                        </button>
                        <button class="disconnect-btn btn-oura-disconnect" onclick="disconnectDevice('oura')" style="display: none; margin-top: 8px;">
                            Disconnect
                        </button>
                    </div>

                    <div class="device-card glass-card">
                        <div class="device-header">
                            <div class="device-icon garmin">
                                <img src="/src/images/GarminConnect.png" alt="Garmin Connect" onerror="this.style.display='none'; this.parentNode.innerHTML='G';">
                            </div>
                            <div class="device-info">
                                <h3>Garmin Connect‚Ñ¢</h3>
                                <p>Activities, body battery, and wellness</p>
                            </div>
                        </div>
                        <button class="connect-btn btn-garmin" onclick="connectDevice('garmin')">
                            Connect with Garmin
                        </button>
                        <button class="disconnect-btn btn-garmin-disconnect" onclick="disconnectDevice('garmin')" style="display: none; margin-top: 8px;">
                            Disconnect
                        </button>
                    </div>

                    <div class="device-card glass-card">
                        <div class="device-header">
                            <div class="device-icon whoop">
                                <img src="/src/images/whoop-logo.jpeg" alt="Whoop" onerror="this.style.display='none'; this.parentNode.innerHTML='W';">
                            </div>
                            <div class="device-info">
                                <h3>Whoop</h3>
                                <p>Recovery, strain, and sleep data</p>
                            </div>
                        </div>
                        <button class="connect-btn btn-whoop" onclick="connectDevice('whoop')">
                            Connect with Whoop
                        </button>
                        <button class="disconnect-btn btn-whoop-disconnect" onclick="disconnectDevice('whoop')" style="display: none; margin-top: 8px;">
                            Disconnect
                        </button>
                    </div>
                </div>
            </div>

            <!-- Overview Tab -->
            <div id="overview" class="tab-panel" role="tabpanel" aria-labelledby="overview-tab">
                <div class="data-connections" id="overviewConnections"></div>

                <div class="analytics-grid">
                    <div class="analytics-card glass-card">
                        <h3>Athlytx Score Trend</h3>
                        <div class="chart-container">
                            <canvas id="scoreTrendChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="analytics-card glass-card">
                        <h3>Score Breakdown</h3>
                        <div class="chart-container">
                            <canvas id="scoreBreakdownChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Strava Data Tab -->
            <div id="strava" class="tab-panel" role="tabpanel" aria-labelledby="strava-tab">
                <!-- Strava Attribution Header -->
                <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; margin-bottom: 20px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Powered by</div>
                    <img src="/src/images/strava.svg" alt="Strava" style="height: 45px; object-fit: contain;">
                </div>

                <div class="analytics-card glass-card">
                    <h3>üèÉ Strava Training Data</h3>
                    <div class="data-summary">
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="stravaActivities">--</span>
                            <div class="summary-label">Activities (7d)</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="stravaDistance">--</span>
                            <div class="summary-label">Total Distance</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="stravaLoad">--</span>
                            <div class="summary-label">Training Load</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="stravaAvgPower">--</span>
                            <div class="summary-label">Avg Power</div>
                        </div>
                    </div>
                </div>

                <div class="analytics-grid">
                    <div class="analytics-card glass-card">
                        <h3>Recent Activities</h3>
                        <div id="stravaActivitiesList" style="max-height: 300px; overflow-y: auto;">
                            <div style="text-align: center; padding: 20px; color: #6b7280;">Connect Strava to see your activities</div>
                        </div>
                    </div>
                    
                    <div class="analytics-card glass-card">
                        <h3>Weekly Training Load</h3>
                        <div class="chart-container">
                            <canvas id="stravaLoadChart"></canvas>
                        </div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>Intensity Distribution (approx.)</h3>
                        <div class="chart-container">
                            <canvas id="stravaIntensityDistChart"></canvas>
                        </div>
                        <div style="font-size: 0.85rem; color:rgba(255,255,255,0.7); margin-top:6px;">Buckets estimated using activity Suffer Score and duration.</div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>Training Monotony</h3>
                        <div class="insight-card" id="stravaMonotonyCard">
                            <p id="stravaMonotonyText">‚Äî</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Oura Data Tab -->
            <div id="oura" class="tab-panel" role="tabpanel" aria-labelledby="oura-tab">
                <!-- Oura Attribution Header -->
                <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; margin-bottom: 20px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Powered by</div>
                    <img src="src/images/ourawhite.png" alt="Oura" style="height: 45px; object-fit: contain;">
                </div>

                <div class="analytics-card glass-card">
                    <h3>üíç Oura Recovery & Sleep</h3>
                    <div class="data-summary">
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="ouraReadiness">--</span>
                            <div class="summary-label">Readiness Score</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="ouraSleep">--</span>
                            <div class="summary-label">Sleep Score</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="ouraHRV">--</span>
                            <div class="summary-label">Avg HRV</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="ouraRHR">--</span>
                            <div class="summary-label">Resting HR</div>
                        </div>
                    </div>
                </div>

                <div class="analytics-grid">
                    <div class="analytics-card glass-card">
                        <h3>Sleep Stages (Last 7 Days)</h3>
                        <div class="chart-container">
                            <canvas id="ouraSleepStagesChart"></canvas>
                        </div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>Readiness vs HRV</h3>
                        <div class="chart-container">
                            <canvas id="ouraCorrelationChart"></canvas>
                        </div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>Readiness & Sleep Score</h3>
                        <div class="chart-container">
                            <canvas id="ouraTrendRS"></canvas>
                        </div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>HRV & Resting HR</h3>
                        <div class="chart-container">
                            <canvas id="ouraTrendHRVHR"></canvas>
                        </div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>Sleep Consistency</h3>
                        <div class="insight-card" id="ouraConsistencyCard">
                            <p id="ouraConsistencyText">‚Äî</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Garmin Data Tab -->
            <div id="garmin" class="tab-panel" role="tabpanel" aria-labelledby="garmin-tab">
                <!-- Garmin Attribution Header -->
                <div style="background: linear-gradient(135deg, rgba(0,112,192,0.15), rgba(0,172,228,0.15)); border-radius: 16px; padding: 28px; margin-bottom: 24px; text-align: center; border: 1px solid rgba(0,172,228,0.3); box-shadow: 0 8px 32px rgba(0,172,228,0.2);">
                    <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 14px; text-transform: uppercase; letter-spacing: 2px; font-weight: 600;">Powered by</div>
                    <img src="src/images/Garmin.svg" alt="Garmin Connect" style="height: 60px; object-fit: contain; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">
                </div>

                <!-- Hero Stats Grid - 4x2 even layout -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 24px;">
                    <!-- Activities -->
                    <div style="background: linear-gradient(135deg, rgba(99,102,241,0.15), rgba(139,92,246,0.15)); padding: 20px; border-radius: 16px; border: 1px solid rgba(139,92,246,0.3); position: relative; overflow: hidden;">
                        <i class="fas fa-running" style="font-size: 48px; position: absolute; top: 10px; right: 10px; opacity: 0.1;"></i>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Activities</div>
                        <div id="garminActivities" style="font-size: 2.5rem; font-weight: 800; color: #fff; margin-bottom: 4px;">--</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">Total Workouts</div>
                        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; align-items: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500; letter-spacing: 0.3px;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Distance -->
                    <div style="background: linear-gradient(135deg, rgba(16,185,129,0.15), rgba(5,150,105,0.15)); padding: 20px; border-radius: 16px; border: 1px solid rgba(16,185,129,0.3); position: relative; overflow: hidden;">
                        <i class="fas fa-route" style="font-size: 48px; position: absolute; top: 10px; right: 10px; opacity: 0.1;"></i>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Distance</div>
                        <div id="garminDistance" style="font-size: 2.5rem; font-weight: 800; color: #fff; margin-bottom: 4px;">--</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">Total Traveled</div>
                        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; align-items: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500; letter-spacing: 0.3px;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Heart Rate -->
                    <div style="background: linear-gradient(135deg, rgba(239,68,68,0.15), rgba(220,38,38,0.15)); padding: 20px; border-radius: 16px; border: 1px solid rgba(239,68,68,0.3); position: relative; overflow: hidden;">
                        <i class="fas fa-heartbeat" style="font-size: 48px; position: absolute; top: 10px; right: 10px; opacity: 0.1;"></i>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Heart Rate</div>
                        <div id="garminAvgHR" style="font-size: 2.5rem; font-weight: 800; color: #fff; margin-bottom: 4px;">--</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">Average BPM</div>
                        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; align-items: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500; letter-spacing: 0.3px;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Training Time -->
                    <div style="background: linear-gradient(135deg, rgba(245,158,11,0.15), rgba(217,119,6,0.15)); padding: 20px; border-radius: 16px; border: 1px solid rgba(245,158,11,0.3); position: relative; overflow: hidden;">
                        <i class="fas fa-clock" style="font-size: 48px; position: absolute; top: 10px; right: 10px; opacity: 0.1;"></i>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Training Time</div>
                        <div id="garminTrainingTime" style="font-size: 2.5rem; font-weight: 800; color: #fff; margin-bottom: 4px;">--</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">Total Duration</div>
                        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; align-items: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500; letter-spacing: 0.3px;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Body Battery -->
                    <div id="garminBodyBatteryCard" style="background: linear-gradient(135deg, rgba(34,197,94,0.15), rgba(22,163,74,0.15)); padding: 20px; border-radius: 16px; border: 1px solid rgba(34,197,94,0.3); position: relative; overflow: hidden;">
                        <i class="fas fa-battery-three-quarters" style="font-size: 48px; position: absolute; top: 10px; right: 10px; opacity: 0.1;"></i>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Body Battery</div>
                        <div id="garminBodyBattery" style="font-size: 2.5rem; font-weight: 800; color: #fff; margin-bottom: 4px;">--</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">Energy Level</div>
                        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; align-items: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500; letter-spacing: 0.3px;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Stress Level -->
                    <div id="garminStressCard" style="background: linear-gradient(135deg, rgba(168,85,247,0.15), rgba(147,51,234,0.15)); padding: 20px; border-radius: 16px; border: 1px solid rgba(168,85,247,0.3); position: relative; overflow: hidden;">
                        <i class="fas fa-brain" style="font-size: 48px; position: absolute; top: 10px; right: 10px; opacity: 0.1;"></i>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Stress Level</div>
                        <div id="garminStressLevel" style="font-size: 2.5rem; font-weight: 800; color: #fff; margin-bottom: 4px;">--</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">Average</div>
                        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; align-items: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500; letter-spacing: 0.3px;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- HRV -->
                    <div id="garminHRVCard" style="background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(37,99,235,0.15)); padding: 20px; border-radius: 16px; border: 1px solid rgba(59,130,246,0.3); position: relative; overflow: hidden;">
                        <i class="fas fa-heart" style="font-size: 48px; position: absolute; top: 10px; right: 10px; opacity: 0.1;"></i>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">HRV</div>
                        <div id="garminHRV" style="font-size: 2.5rem; font-weight: 800; color: #fff; margin-bottom: 4px;">--</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">Variability (ms)</div>
                        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; align-items: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500; letter-spacing: 0.3px;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Respiration -->
                    <div id="garminRespirationCard" style="background: linear-gradient(135deg, rgba(20,184,166,0.15), rgba(13,148,136,0.15)); padding: 20px; border-radius: 16px; border: 1px solid rgba(20,184,166,0.3); position: relative; overflow: hidden;">
                        <i class="fas fa-lungs" style="font-size: 48px; position: absolute; top: 10px; right: 10px; opacity: 0.1;"></i>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Respiration</div>
                        <div id="garminRespiration" style="font-size: 2.5rem; font-weight: 800; color: #fff; margin-bottom: 4px;">--</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">Breaths/Min</div>
                        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; align-items: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500; letter-spacing: 0.3px;">Powered by Garmin</span>
                        </div>
                    </div>
                </div>

                <div class="analytics-grid">
                    <!-- Activities List -->
                    <div class="analytics-card glass-card" style="grid-column: span 2;">
                        <h3 style="display: flex; align-items: center; gap: 10px; justify-content: space-between;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <i class="fas fa-running"></i>
                                Recent Activities
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                                <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500;">Powered by Garmin</span>
                            </div>
                        </h3>
                        <div id="garminActivitiesList" style="max-height: 500px; overflow-y: auto;">
                            <div style="text-align: center; padding: 40px; color: #6b7280;">
                                <i class="fas fa-watch" style="font-size: 3rem; margin-bottom: 16px; opacity: 0.3;"></i>
                                <div style="font-size: 1.1rem; margin-bottom: 8px;">Connect Garmin to see your activities</div>
                                <div style="font-size: 0.9rem; opacity: 0.7;">Sync your workouts, health metrics, and more</div>
                            </div>
                        </div>
                    </div>

                    <!-- Heart Rate Zones -->
                    <div class="analytics-card glass-card">
                        <h3 style="display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-heartbeat"></i>
                            Time in Heart Rate Zones
                        </h3>
                        <div class="chart-container">
                            <canvas id="garminZonesChart"></canvas>
                        </div>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-top: 12px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Body Battery Trend -->
                    <div class="analytics-card glass-card">
                        <h3 style="display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-battery-three-quarters"></i>
                            Body Battery Trend
                        </h3>
                        <div class="chart-container">
                            <canvas id="garminBodyBatteryChart"></canvas>
                        </div>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-top: 12px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Stress Analysis -->
                    <div class="analytics-card glass-card">
                        <h3 style="display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-brain"></i>
                            Stress Distribution
                        </h3>
                        <div class="chart-container">
                            <canvas id="garminStressChart"></canvas>
                        </div>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-top: 12px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500;">Powered by Garmin</span>
                        </div>
                    </div>

                    <!-- Respiration & HRV -->
                    <div class="analytics-card glass-card">
                        <h3 style="display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-heart"></i>
                            HRV & Respiration
                        </h3>
                        <div class="chart-container">
                            <canvas id="garminHRVRespirationChart"></canvas>
                        </div>
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-top: 12px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 6px;">
                            <img src="src/images/Garmin.svg" alt="Garmin" style="height: 12px; opacity: 0.85;">
                            <span style="font-size: 10px; color: rgba(255,255,255,0.85); font-weight: 500;">Powered by Garmin</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Whoop Data Tab -->
            <div id="whoop" class="tab-panel" role="tabpanel" aria-labelledby="whoop-tab">
                <!-- Whoop Attribution Header -->
                <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; margin-bottom: 20px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">Powered by</div>
                    <img src="src/images/WHOOP.svg" alt="Whoop" style="height: 45px; object-fit: contain; filter: invert(1) brightness(2);">
                </div>

                <div class="analytics-card glass-card">
                    <h3><i class="fas fa-dumbbell"></i> Whoop Strain & Recovery</h3>
                    <div class="data-summary">
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="whoopRecovery">--</span>
                            <div class="summary-label">Recovery %</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="whoopStrain">--</span>
                            <div class="summary-label">Strain Score</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="whoopSleep">--</span>
                            <div class="summary-label">Sleep Performance %</div>
                        </div>
                        <div class="summary-card glass-card">
                            <span class="summary-value" id="whoopHRV">--</span>
                            <div class="summary-label">HRV (ms)</div>
                        </div>
                    </div>
                </div>

                <div class="analytics-grid">
                    <div class="analytics-card glass-card">
                        <h3>Recent Activities</h3>
                        <div id="whoopActivitiesList" style="max-height: 300px; overflow-y: auto;">
                            <div style="text-align: center; padding: 20px; color: #6b7280;">Connect Whoop to see your activities</div>
                        </div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>Sleep & Recovery Trend</h3>
                        <div class="chart-container">
                            <canvas id="whoopTrendChart"></canvas>
                        </div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>Recovery Trend</h3>
                        <div class="chart-container">
                            <canvas id="whoopRecoveryTrendChart"></canvas>
                        </div>
                    </div>

                    <div class="analytics-card glass-card">
                        <h3>Today's Strain Target</h3>
                        <div class="insight-card" id="whoopStrainTargetCard">
                            <p id="whoopStrainTargetText">‚Äî</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Running Tab -->
            <div id="running" class="tab-panel" role="tabpanel" aria-labelledby="running-tab">
                <!-- Running Volume Cards -->
                <div class="data-summary" style="margin-bottom: 30px;">
                    <div class="summary-card glass-card">
                        <span class="summary-value" id="runningDistance">--</span>
                        <div class="summary-label">Total Distance (4w)</div>
                        <span class="trend-arrow" id="runningDistanceTrend"></span>
                    </div>
                    <div class="summary-card glass-card">
                        <span class="summary-value" id="runningFrequency">--</span>
                        <div class="summary-label">Runs per Week</div>
                        <span class="trend-arrow" id="runningFrequencyTrend"></span>
                    </div>
                    <div class="summary-card glass-card">
                        <span class="summary-value" id="runningDuration">--</span>
                        <div class="summary-label">Avg Duration</div>
                        <span class="trend-arrow" id="runningDurationTrend"></span>
                    </div>
                    <div class="summary-card glass-card">
                        <span class="summary-value" id="runningElevation">--</span>
                        <div class="summary-label">Elevation Gain (4w)</div>
                        <span class="trend-arrow" id="runningElevationTrend"></span>
                    </div>
                </div>

                <!-- Training Load Analysis -->
                <div class="analytics-card glass-card">
                    <h3>Training Load Analysis</h3>
                    <div class="chart-container">
                        <canvas id="runningLoadChart"></canvas>
                    </div>
                    <div class="insight-card" id="runningLoadInsight" style="margin-top: 15px;">
                        <p>Connect Strava to see your training load analysis</p>
                    </div>
                </div>

                <!-- Pace & Performance Trends -->
                <div class="analytics-grid">
                    <div class="analytics-card glass-card">
                        <h3>‚ö° Pace & Heart Rate Trends</h3>
                        <div class="chart-container">
                            <canvas id="runningPaceChart"></canvas>
                        </div>
                        <div class="insight-card" id="runningPaceInsight" style="margin-top: 15px;">
                            <p>Track your pace improvements over time</p>
                        </div>
                    </div>
                    
                    <div class="analytics-card glass-card">
                        <h3>üéØ Training Intensity Distribution</h3>
                        <div class="chart-container">
                            <canvas id="runningIntensityChart"></canvas>
                        </div>
                        <div class="intensity-legend" style="margin-top: 15px;">
                            <div style="display: flex; justify-content: space-around; text-align: center;">
                                <div><span style="color: #10b981;">‚óè</span> Easy</div>
                                <div><span style="color: #f59e0b;">‚óè</span> Moderate</div>
                                <div><span style="color: #dc2626;">‚óè</span> Hard</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Progress & Records -->
                <div class="analytics-grid">
                    <div class="analytics-card glass-card">
                        <h3>üìà Progress Highlights</h3>
                        <div id="runningProgressTable" style="overflow-x: auto;">
                            <table style="width: 100%; font-size: 0.9rem;">
                                <thead>
                                    <tr style="border-bottom: 2px solid rgba(255,255,255,0.2);">
                                        <th style="text-align: left; padding: 12px; color: #ffffff; font-weight: 600;">Metric</th>
                                        <th style="text-align: center; padding: 12px; color: #ffffff; font-weight: 600;">4 Weeks Ago</th>
                                        <th style="text-align: center; padding: 12px; color: #ffffff; font-weight: 600;">This Week</th>
                                        <th style="text-align: center; padding: 12px; color: #ffffff; font-weight: 600;">Change</th>
                                    </tr>
                                </thead>
                                <tbody id="runningProgressBody">
                                    <tr>
                                        <td colspan="4" style="text-align: center; padding: 20px; color: #ffffff;">
                                            Loading progress data...
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="analytics-card glass-card">
                        <h3>üèÖ Personal Records</h3>
                        <div id="runningRecords" style="max-height: 300px; overflow-y: auto;">
                            <div class="record-item" style="padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: #6B7280;">Connect Strava to see your records</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Endurance Timeline -->
                <div class="analytics-card glass-card">
                    <h3>üèÉ‚Äç‚ôÇÔ∏è Endurance Development</h3>
                    <div class="chart-container">
                        <canvas id="runningEnduranceChart"></canvas>
                    </div>
                    <div class="insight-card" id="runningEnduranceInsight" style="margin-top: 15px;">
                        <p>Track your longest runs and endurance progression</p>
                    </div>
                </div>
            </div>

            <!-- AI Insights Tab -->
            <div id="insights" class="tab-panel" role="tabpanel" aria-labelledby="insights-tab">
                <div class="analytics-grid">
                    <div class="analytics-card glass-card" style="background: linear-gradient(135deg, #3210b9 0%, #059669 100%); color: white;">
                        <h3 style="color: white;">ü§ñ AI-Powered Insights</h3>
                        <div id="aiInsights">
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin: 10px 0;">
                                <strong>Data Analysis:</strong> Connect your devices to get personalized insights based on your multi-stream data.
                            </div>
                        </div>
                    </div>
                    <div class="analytics-card glass-card">
                        <h3>Cross-Device Correlations</h3>
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                            <label for="correlationWindow" style="font-size:0.9rem; color:rgba(255,255,255,0.7);">Window:</label>
                            <select id="correlationWindow" style="font-size:0.9rem; padding:4px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.2); background:rgba(255,255,255,0.1); color:white;">
                                <option value="7">7 days</option>
                                <option value="14">14 days</option>
                                <option value="28">28 days</option>
                            </select>
                            <span style="font-size:0.85rem; color:rgba(255,255,255,0.7);">Adjust to explore relationships over time</span>
                        </div>
                        <div class="chart-container" style="height: 240px;">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                                <div style="font-weight:600; color:rgba(255,255,255,0.95);">Load vs Recovery</div>
                                <div id="loadRecoveryR" style="font-size:0.85rem; color:rgba(255,255,255,0.7);">r: --</div>
                            </div>
                            <canvas id="loadRecoveryChart"></canvas>
                        </div>
                        <div class="chart-container" style="height: 240px; margin-top: 16px;">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                                <div style="font-weight:600; color:rgba(255,255,255,0.95);">Sleep vs Next‚Äëday Load</div>
                                <div id="sleepLoadR" style="font-size:0.85rem; color:rgba(255,255,255,0.7);">r: --</div>
                            </div>
                            <canvas id="sleepLoadChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Contact Tab -->
            <div id="contact" class="tab-panel" role="tabpanel" aria-labelledby="contact-tab">
                <div class="analytics-card glass-card" style="max-width: 600px; margin: 0 auto;">
                    <h3>üìß Get in Touch</h3>
                    <p style="color: rgba(255, 255, 255, 0.8); margin-bottom: 30px;">
                        Have questions or feedback? We'd love to hear from you!
                    </p>

                    <form id="contactForm" style="display: flex; flex-direction: column; gap: 20px;">
                        <div>
                            <label for="contactName" style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.9); font-weight: 600;">Name</label>
                            <input
                                type="text"
                                id="contactName"
                                required
                                style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: white; font-size: 14px;"
                                placeholder="Your name"
                            />
                        </div>

                        <div>
                            <label for="contactEmail" style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.9); font-weight: 600;">Email</label>
                            <input
                                type="email"
                                id="contactEmail"
                                required
                                style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: white; font-size: 14px;"
                                placeholder="your.email@example.com"
                            />
                        </div>

                        <div>
                            <label for="contactSubject" style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.9); font-weight: 600;">Subject</label>
                            <input
                                type="text"
                                id="contactSubject"
                                required
                                style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: white; font-size: 14px;"
                                placeholder="What's this about?"
                            />
                        </div>

                        <div>
                            <label for="contactMessage" style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.9); font-weight: 600;">Message</label>
                            <textarea
                                id="contactMessage"
                                required
                                rows="6"
                                style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: white; font-size: 14px; resize: vertical; font-family: inherit;"
                                placeholder="Tell us what's on your mind..."
                            ></textarea>
                        </div>

                        <button
                            type="submit"
                            class="refresh-btn"
                            style="background: linear-gradient(135deg, #667eea, #764ba2); border: none; padding: 14px 28px; font-size: 16px; font-weight: 600; cursor: pointer; align-self: flex-start;"
                        >
                            Send Message
                        </button>

                        <div id="contactFormStatus" style="display: none; padding: 12px; border-radius: 8px; margin-top: 10px;"></div>
                    </form>
                </div>
            </div>
            </div> <!-- End tab-content-wrapper -->
        </div>
    </div>

    <!-- Fixed Footer -->
    <footer class="main-footer">
        <div class="footer-brands">
            <div class="footer-brands-label">Powered by Garmin, Strava, Whoop, and Oura</div>
            <div class="footer-brands-logos">
                <img src="src/images/Garmin.svg" alt="Garmin" class="brand-logo brand-logo-garmin">
                <span class="brand-separator">|</span>
                <img src="src/images/strava.svg" alt="Strava" class="brand-logo brand-logo-strava">
                <span class="brand-separator">|</span>
                <img src="src/images/WHOOP.svg" alt="Whoop" class="brand-logo brand-logo-whoop">
                <span class="brand-separator">|</span>
                <img src="src/images/ourawhite.png" alt="Oura" class="brand-logo brand-logo-oura">
            </div>
        </div>
        <div class="footer-links">
            <a href="/about.html">About</a>
            <a href="/privacy.html">Privacy Policy</a>
            <a href="mailto:privacy@athlytx.com">Contact</a>
            <a href="/terms.html">Terms of Service</a>
        </div>
        <div class="footer-text">
            ¬© 2025 Athlytx. Advanced fitness analytics platform.
        </div>
    </footer>

    <script>
        // ===== API CONFIGURATION =====
        const API_CONFIG = {
            backend: 'https://athlytx-backend-production.up.railway.app',
            strava: {
                clientId: '167615',
                redirectUri: 'https://www.athlytx.com',
                scope: 'read,activity:read_all,profile:read_all'
            },
            oura: {
                clientId: 'RVT72X5LNV2K6GGK',
                redirectUri: 'https://www.athlytx.com',
                scope: 'daily'
            },
            garmin: {
                // PRODUCTION Garmin app (correct ID)
                clientId: '4af31e5c-d758-442d-a007-809ea45f444a',
                clientSecret: 'GGDcZxqPhpn4UlVihFY62rHWhY+ZNkHbLE0auOYOkrU',
                redirectUri: 'https://www.athlytx.com/auth/garmin/callback',
                scope: 'WELLNESS_READ'
            },
            whoop: {
                clientId: '31c6c2ac-890c-46ef-81da-b961c1cb1ca7',
                redirectUri: 'https://www.athlytx.com',
                scope: 'read:recovery read:cycles read:workout read:sleep read:profile'
            }
        };

        // ===== INSIGHT SETTINGS =====
        const INSIGHT_THRESHOLDS = {
            overreachingAvgStrain: 16,
            overreachingAvgWithDecline: 15,
            sleepAgreementLow: 60,            // % agreement cutoff
            sleepAgreementGood: 70,           // % considered good agreement
            loadUpPct: 0.30,                  // +30%
            recDownPct: -0.15,                // -15%
            workloadRatioHigh: 1.5,           // acute:chronic high
            workloadRatioLow: 0.5,            // significant reduction if prev load > 100
            sleepDebtPerfLow: 85              // Whoop sleep performance %
        };

        function getInsightWindowDays() {
            const d = parseInt(localStorage.getItem('insight_window_days') || '7', 10);
            return [7,14,28].includes(d) ? d : 7;
        }

        // ===== UTILITY FUNCTIONS =====
        // Helper function to convert minutes to hours:minutes format
        function formatDuration(minutes) {
            if (minutes < 60) {
                return `${Math.round(minutes)} min`;
            }
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = Math.round(minutes % 60);
            if (remainingMinutes === 0) {
                return `${hours}h`;
            }
            return `${hours}h ${remainingMinutes}min`;
        }

        // ===== GLOBAL DATA STORAGE =====
        let fitnessData = {
            strava: null,
            oura: null,
            whoop: null,
            garmin: null,
            lastUpdated: null
        };

        let charts = {};

        // ===== PKCE HELPER FUNCTIONS FOR GARMIN =====
        function generateCodeVerifier() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return base64URLEncode(array);
        }
        
        async function generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return base64URLEncode(new Uint8Array(hash));
        }
        
        function base64URLEncode(buffer) {
            const base64 = btoa(String.fromCharCode.apply(null, buffer));
            return base64
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        // ===== DEVICE CONNECTION FUNCTIONS =====
        async function connectDevice(device) {
            const button = event.target;
            
            if (device === 'strava') {
                const authUrl = `https://www.strava.com/oauth/authorize?client_id=${API_CONFIG.strava.clientId}&response_type=code&redirect_uri=${encodeURIComponent(API_CONFIG.strava.redirectUri)}&scope=${API_CONFIG.strava.scope}&state=strava_auth&approval_prompt=force`;
                window.location.href = authUrl;
                
            } else if (device === 'oura') {
                const authUrl = `https://cloud.ouraring.com/oauth/authorize?response_type=code&client_id=${API_CONFIG.oura.clientId}&redirect_uri=${encodeURIComponent(API_CONFIG.oura.redirectUri)}&scope=daily+workout+heartrate&state=oura_auth`;
                window.location.href = authUrl;
                
            } else if (device === 'garmin') {
                showMessage('Redirecting to Garmin for authorization...', 'info');

                // Use the GarminOAuth2 class from garmin-oauth2.js
                if (typeof GarminOAuth2 !== 'undefined') {
                    const garminOAuth = new GarminOAuth2({
                        clientId: API_CONFIG.garmin.clientId,
                        redirectUri: API_CONFIG.garmin.redirectUri,
                        scope: 'WELLNESS_READ'
                    });

                    const authUrl = await garminOAuth.buildAuthorizationUrl();
                    window.location.href = authUrl;
                } else {
                    // Fallback: manual OAuth flow with proper state storage
                    const codeVerifier = generateCodeVerifier();
                    const codeChallenge = await generateCodeChallenge(codeVerifier);
                    const state = 'garmin_auth';

                    // Store both verifier AND state for token exchange
                    localStorage.setItem('garmin_code_verifier', codeVerifier);
                    sessionStorage.setItem('garmin_code_verifier', codeVerifier);
                    sessionStorage.setItem('garmin_oauth_state', state);

                    const params = new URLSearchParams({
                        client_id: API_CONFIG.garmin.clientId,
                        response_type: 'code',
                        redirect_uri: API_CONFIG.garmin.redirectUri,
                        scope: 'WELLNESS_READ',
                        state: state,
                        code_challenge: codeChallenge,
                        code_challenge_method: 'S256'
                    });

                    const authUrl = `https://connect.garmin.com/oauth2Confirm?${params.toString()}`;
                    console.log('Attempting Garmin OAuth via correct endpoint:', authUrl);
                    window.location.href = authUrl;
                }
            } else if (device === 'whoop') {
                // This will be handled by the oauth-handler.js
                showMessage('Redirecting to Whoop for authorization...', 'info');
            }
        }

        function disconnectDevice(device) {
            if (!confirm(`Are you sure you want to disconnect ${device.charAt(0).toUpperCase() + device.slice(1)}?`)) {
                return;
            }

            // Clear localStorage tokens
            if (device === 'strava') {
                localStorage.removeItem('strava_token');
                localStorage.removeItem('strava_expiry');
                localStorage.removeItem('strava_refresh_token');
            } else if (device === 'oura') {
                localStorage.removeItem('oura_token');
                localStorage.removeItem('oura_expiry');
            } else if (device === 'garmin') {
                localStorage.removeItem('garmin_token');
                localStorage.removeItem('garmin_expiry');
                localStorage.removeItem('garmin_refresh_token');
                localStorage.removeItem('garmin_access_token');
                localStorage.removeItem('garmin_token_expires_at');
            } else if (device === 'whoop') {
                localStorage.removeItem('whoop_token');
                localStorage.removeItem('whoop_expiry');
                localStorage.removeItem('whoop_refresh_token');
            }

            // Update button visibility
            const connectBtn = document.querySelector(`.btn-${device}`);
            const disconnectBtn = document.querySelector(`.btn-${device}-disconnect`);

            if (connectBtn) {
                connectBtn.innerHTML = `Connect ${device.charAt(0).toUpperCase() + device.slice(1)}`;
                connectBtn.disabled = false;
                connectBtn.style.display = 'flex';
            }

            if (disconnectBtn) {
                disconnectBtn.style.display = 'none';
            }

            showMessage(`${device.charAt(0).toUpperCase() + device.slice(1)} disconnected`, 'info');

            // Reload page to clear data
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }

        // ===== OAUTH CALLBACK HANDLING =====
        window.addEventListener('load', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const error = urlParams.get('error');
            
            // Check for OAuth errors
            if (error) {
                console.error('OAuth error:', error, urlParams.get('error_description'));
                showMessage(`Authentication failed: ${error}`, 'error');
                sessionStorage.removeItem('processed_oauth_code');
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
            
            // Check for Garmin ticket accumulation (sign of redirect loop)
            const tickets = urlParams.toString().match(/ticket=/g);
            if (tickets && tickets.length > 1) {
                console.error('Garmin redirect loop detected - multiple tickets found');
                showMessage('Garmin Connect authorization failed - please try again', 'error');
                sessionStorage.removeItem('processed_oauth_code');
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
            
            // Prevent processing the same code twice
            const processedCode = sessionStorage.getItem('processed_oauth_code');
            if (code && code === processedCode) {
                console.log('OAuth code already processed, skipping');
                return;
            }
            
            if (code && state === 'strava_auth') {
                sessionStorage.setItem('processed_oauth_code', code);
                handleStravaCallback(code);
                window.history.replaceState({}, document.title, window.location.pathname);
            } else if (code && state === 'oura_auth') {
                sessionStorage.setItem('processed_oauth_code', code);
                handleOuraCallback(code);
                window.history.replaceState({}, document.title, window.location.pathname);
            } else if (code && state === 'garmin_auth') {
                // Handle Garmin OAuth 2.0 callback (legacy direct callback)
                console.log('Processing Garmin callback with code:', code);
                sessionStorage.setItem('processed_oauth_code', code);
                handleGarminCallback(code);
                window.history.replaceState({}, document.title, window.location.pathname);
            }

            // Handle clean URL Garmin callback (from server-side redirect)
            const garminCode = urlParams.get('garmin_code');
            const garminState = urlParams.get('garmin_state');
            const provider = urlParams.get('provider');

            if (provider === 'garmin' && garminCode && garminState) {
                console.log('Processing Garmin callback (clean URL) with code:', garminCode);
                sessionStorage.setItem('processed_oauth_code', garminCode);

                // Call handleGarminCallback with the code
                // We need to temporarily set the state for validation
                const originalState = sessionStorage.getItem('garmin_oauth_state') || garminState;
                sessionStorage.setItem('garmin_oauth_state', originalState);

                handleGarminCallback(garminCode);

                // Clean up URL completely
                window.history.replaceState({}, document.title, '/');
            }

            // Add small delay to ensure Chart.js is loaded
            setTimeout(() => {
                initializeCharts();
                loadExistingConnections();
                updateConnectionStatus();
            }, 100);
        });

        // ===== TOKEN MANAGEMENT =====
        async function saveTokenToDatabase(provider, accessToken, refreshToken = null, expiresAt = null, providerUserId = null) {
            try {
                // Get userId from localStorage - this ensures we always use the same user
                const userId = localStorage.getItem('userId');

                const response = await fetch(`${API_CONFIG.backend}/api/sync/save-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId, // Pass userId to ensure tokens are saved to correct user
                        provider,
                        accessToken,
                        refreshToken,
                        expiresAt,
                        providerUserId // Garmin GUID for mapping Health API push data
                    })
                });

                if (!response.ok) {
                    console.error('Failed to save token to database:', await response.text());
                    return false;
                }

                const result = await response.json();
                console.log(`‚úÖ Token saved to database for ${provider}:`, result);

                // Store the userId returned from backend (in case it was created)
                if (result.userId) {
                    localStorage.setItem('userId', result.userId);
                }

                return true;
            } catch (error) {
                console.error('Error saving token to database:', error);
                return false;
            }
        }

        // ===== CONNECTION MANAGEMENT =====
        function loadExistingConnections() {
            console.log('üîç Loading existing connections...');
            const stravaToken = localStorage.getItem('strava_token');
            const ouraToken = localStorage.getItem('oura_token');
            const garminToken = localStorage.getItem('garmin_token');
            const whoopToken = localStorage.getItem('whoop_token');
            const garminTokenSecret = localStorage.getItem('garmin_token_secret');
            const stravaExpiry = localStorage.getItem('strava_expiry');
            const ouraExpiry = localStorage.getItem('oura_expiry');
            const whoopExpiry = localStorage.getItem('whoop_expiry');

            const now = Date.now();

            console.log('üîë Found tokens:', {
                strava: !!stravaToken,
                oura: !!ouraToken,
                garmin: !!garminToken,
                whoop: !!whoopToken
            });
            
            if (stravaToken && (!stravaExpiry || now < parseInt(stravaExpiry))) {
                fetchStravaData(stravaToken);
            } else if (stravaToken) {
                localStorage.removeItem('strava_token');
                localStorage.removeItem('strava_expiry');
            }
            
            if (ouraToken && (!ouraExpiry || now < parseInt(ouraExpiry))) {
                fetchOuraData(ouraToken);
            } else if (ouraToken) {
                localStorage.removeItem('oura_token');
                localStorage.removeItem('oura_expiry');
            }
            
            // Check Garmin OAuth 2.0 token
            const garminExpiry = localStorage.getItem('garmin_expiry');
            if (garminToken && (!garminExpiry || now < parseInt(garminExpiry))) {
                fetchGarminData();
            } else if (garminToken) {
                localStorage.removeItem('garmin_token');
                localStorage.removeItem('garmin_expiry');
            }

            // Check Whoop OAuth 2.0 token
            if (whoopToken && (!whoopExpiry || now < parseInt(whoopExpiry))) {
                console.log('‚úÖ Found valid Whoop token, fetching data...');
                fetchWhoopData(whoopToken);
            } else if (whoopToken && whoopExpiry && now >= parseInt(whoopExpiry)) {
                console.log('‚è∞ Whoop token expired, attempting to refresh...');
                const refreshToken = localStorage.getItem('whoop_refresh_token');
                if (refreshToken) {
                    refreshWhoopToken(refreshToken);
                } else {
                    console.log('‚ùå No refresh token available, clearing...');
                    localStorage.removeItem('whoop_token');
                    localStorage.removeItem('whoop_expiry');
                }
            }
        }

        async function handleStravaCallback(code) {
            try {
                showMessage('Processing Strava authorization...', 'info');
                
                const response = await fetch(`${API_CONFIG.backend}/api/strava/token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code })
                });

                if (!response.ok) {
                    throw new Error(`Backend error: ${response.status}`);
                }

                const data = await response.json();
                
                if (data.access_token) {
                    localStorage.setItem('strava_token', data.access_token);
                    if (data.expires_at) {
                        localStorage.setItem('strava_expiry', data.expires_at * 1000);
                    }

                    // Save to database
                    await saveTokenToDatabase(
                        'strava',
                        data.access_token,
                        data.refresh_token,
                        data.expires_at ? new Date(data.expires_at * 1000).toISOString() : null
                    );

                    await fetchStravaData(data.access_token);
                } else {
                    throw new Error('No access token received');
                }
                
            } catch (error) {
                console.error('Strava callback error:', error);
                showMessage(`Strava connection failed: ${error.message}`, 'error');
                
                const button = document.querySelector('.btn-strava');
                button.innerHTML = 'Connect Strava';
                button.disabled = false;
            }
        }

        async function handleOuraCallback(code) {
            try {
                showMessage('Processing Oura authorization...', 'info');
                
                const response = await fetch(`${API_CONFIG.backend}/api/oura/token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Backend error: ${response.status} - ${errorData.error || 'Unknown error'}`);
                }

                const data = await response.json();
                
                if (data.access_token) {
                    localStorage.setItem('oura_token', data.access_token);
                    let expiryTime = null;
                    if (data.expires_in) {
                        expiryTime = Date.now() + (data.expires_in * 1000);
                        localStorage.setItem('oura_expiry', expiryTime);
                    }

                    // Save to database
                    await saveTokenToDatabase(
                        'oura',
                        data.access_token,
                        data.refresh_token,
                        expiryTime ? new Date(expiryTime).toISOString() : null
                    );

                    await fetchOuraData(data.access_token);
                } else {
                    throw new Error('No access token received');
                }
                
            } catch (error) {
                console.error('Oura callback error:', error);
                showMessage(`Oura connection failed: ${error.message}`, 'error');
                
                const button = document.querySelector('.btn-oura');
                button.innerHTML = 'Connect Oura';
                button.disabled = false;
            }
        }

        // Garmin OAuth 2.0 callback handler with PKCE
        async function handleGarminCallback(code) {
            try {
                showMessage('Processing Garmin Connect authorization...', 'info');
                console.log('Garmin auth code received:', code);
                
                // Get the PKCE verifier (try localStorage first for mobile compatibility)
                const codeVerifier = localStorage.getItem('garmin_code_verifier') || sessionStorage.getItem('garmin_code_verifier');
                
                // Your backend should exchange the code with Garmin's token endpoint
                const response = await fetch(`${API_CONFIG.backend}/api/garmin/token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        code,
                        client_id: API_CONFIG.garmin.clientId,
                        redirect_uri: API_CONFIG.garmin.redirectUri,
                        code_verifier: codeVerifier  // PKCE verifier for OAuth 2.0
                    })
                });

                console.log('Token exchange response:', response.status);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Backend error response:', errorText);
                    throw new Error(`Backend error: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                
                if (data.access_token) {
                    // Store Garmin OAuth 2.0 token
                    localStorage.setItem('garmin_token', data.access_token);
                    let expiryTime = null;
                    if (data.refresh_token) {
                        localStorage.setItem('garmin_refresh_token', data.refresh_token);
                    }
                    if (data.expires_in) {
                        expiryTime = Date.now() + (data.expires_in * 1000);
                        localStorage.setItem('garmin_expiry', expiryTime);
                    }

                    // Extract Garmin User ID
                    let garminUserId = null;

                    // First, try to get it from the backend response (from User ID endpoint)
                    if (data.garminUserId) {
                        garminUserId = data.garminUserId;
                        console.log('‚úÖ Got Garmin User ID from backend:', garminUserId);
                    } else {
                        // Fallback: Try to extract from JWT token
                        try {
                            const payload = JSON.parse(atob(data.access_token.split('.')[1]));
                            console.log('üîç Full JWT payload:', JSON.stringify(payload, null, 2));

                            // Try multiple possible field names for Garmin user ID
                            garminUserId = payload.garmin_guid || payload.user_id || payload.sub || payload.userId;

                            console.log('‚úÖ Extracted Garmin User ID from JWT:', garminUserId);
                            console.log('Available fields in token:', Object.keys(payload));
                        } catch (e) {
                            console.warn('‚ö†Ô∏è  Could not extract Garmin User ID from token:', e);
                        }
                    }

                    // Save to database with Garmin User ID
                    await saveTokenToDatabase(
                        'garmin',
                        data.access_token,
                        data.refresh_token,
                        expiryTime ? new Date(expiryTime).toISOString() : null,
                        garminUserId
                    );

                    // Clean up PKCE verifier from both storages
                    localStorage.removeItem('garmin_code_verifier');
                    sessionStorage.removeItem('garmin_code_verifier');
                    
                    showMessage('Garmin connected successfully!', 'success');
                    await fetchGarminData(data.access_token);
                } else {
                    throw new Error('No access token received');
                }
                
            } catch (error) {
                console.error('Garmin callback error:', error);
                showMessage(`Failed to connect Garmin: ${error.message}`, 'error');
            }
        }

        // Enhanced error handling with retry logic
        async function fetchWithRetry(url, options = {}, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    
                    if (!response.ok) {
                        // Handle specific error codes
                        if (response.status === 401) {
                            throw new Error('Authentication expired. Please reconnect.');
                        } else if (response.status === 429) {
                            // Rate limiting - wait before retry
                            const retryAfter = response.headers.get('Retry-After') || (i + 1) * 5;
                            showMessage(`Rate limited. Retrying in ${retryAfter} seconds...`, 'warning');
                            await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
                            continue;
                        } else if (response.status >= 500) {
                            throw new Error(`Server error (${response.status}). Please try again later.`);
                        }
                        throw new Error(`Request failed: ${response.status}`);
                    }
                    
                    return response;
                } catch (error) {
                    if (i === retries - 1) throw error;
                    
                    // Network errors - exponential backoff
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        const delay = Math.min(1000 * Math.pow(2, i), 10000);
                        showMessage(`Network error. Retrying in ${delay/1000}s...`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw error;
                    }
                }
            }
        }

        // Enhanced data fetching with better error handling
        async function fetchStravaData(token) {
            const button = document.querySelector('.btn-strava');
            
            try {
                button.innerHTML = '<span class="loading-spinner"></span> Loading...';
                button.disabled = true;
                
                const [athleteResponse, activitiesResponse] = await Promise.all([
                    fetchWithRetry(`${API_CONFIG.backend}/api/strava/athlete?token=${token}`),
                    fetchWithRetry(`${API_CONFIG.backend}/api/strava/activities?token=${token}`)
                ]);

                const athlete = await athleteResponse.json();
                const activitiesData = await activitiesResponse.json();

                // Validate response data
                if (!athlete || typeof athlete !== 'object') {
                    throw new Error('Invalid athlete data received');
                }

                fitnessData.strava = {
                    athlete,
                    activities: Array.isArray(activitiesData.activities) ? activitiesData.activities : [],
                    lastUpdated: new Date().toISOString()
                };

                button.innerHTML = `‚úÖ ${athlete.firstname || 'Strava'} - Connected`;
                button.disabled = false;

                // Show disconnect button
                const disconnectBtn = document.querySelector('.btn-strava-disconnect');
                if (disconnectBtn) {
                    disconnectBtn.style.display = 'block';
                }

                showMessage(`Strava connected! Found ${fitnessData.strava.activities.length} activities`, 'success');
                updateAnalytics();
                updateConnectionStatus();

            } catch (error) {
                console.error('Error fetching Strava data:', error);
                
                // Handle specific errors
                if (error.message.includes('Authentication expired')) {
                    localStorage.removeItem('strava_token');
                    localStorage.removeItem('strava_expiry');
                    button.innerHTML = 'Connect Strava';
                    showMessage('Strava authentication expired. Please reconnect.', 'error');
                } else if (error.message.includes('Network')) {
                    button.innerHTML = '‚ö†Ô∏è Retry Strava';
                    showMessage('Network issue. Check your connection and try again.', 'error');
                } else {
                    button.innerHTML = '‚ùå Strava Error';
                    showMessage(`Strava error: ${error.message}`, 'error');
                }
                
                button.disabled = false;
                
                // Set partial data to prevent null errors
                if (!fitnessData.strava) {
                    fitnessData.strava = {
                        athlete: null,
                        activities: [],
                        error: error.message,
                        lastUpdated: new Date().toISOString()
                    };
                }
            }
        }

        async function fetchOuraData(token) {
            const button = document.querySelector('.btn-oura');
            
            try {
                button.innerHTML = '<span class="loading-spinner"></span> Loading...';
                button.disabled = true;
                
                const today = new Date();
                const startDate = new Date(today.getTime() - 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                const endDate = today.toISOString().split('T')[0];

                const [personalResponse, sleepResponse, readinessResponse, activityResponse] = await Promise.allSettled([
                    fetchWithRetry(`${API_CONFIG.backend}/api/oura/personal?token=${token}`).catch(e => ({ ok: false, error: e })),
                    fetchWithRetry(`${API_CONFIG.backend}/api/oura/sleep?token=${token}&start_date=${startDate}&end_date=${endDate}`).catch(e => ({ ok: false, error: e })),
                    fetchWithRetry(`${API_CONFIG.backend}/api/oura/readiness?token=${token}&start_date=${startDate}&end_date=${endDate}`).catch(e => ({ ok: false, error: e })),
                    fetchWithRetry(`${API_CONFIG.backend}/api/oura/activity?token=${token}&start_date=${startDate}&end_date=${endDate}`).catch(e => ({ ok: false, error: e }))
                ]);

                let personal = null, sleep = null, readiness = null, activity = null;
                let hasAnyData = false;

                // Process responses with validation
                if (personalResponse.status === 'fulfilled' && personalResponse.value.ok) {
                    const data = await personalResponse.value.json();
                    if (data && typeof data === 'object') {
                        personal = data;
                        hasAnyData = true;
                    }
                }

                if (sleepResponse.status === 'fulfilled' && sleepResponse.value.ok) {
                    const data = await sleepResponse.value.json();
                    if (data && Array.isArray(data.data)) {
                        sleep = data;
                        hasAnyData = true;
                    }
                }

                if (readinessResponse.status === 'fulfilled' && readinessResponse.value.ok) {
                    const data = await readinessResponse.value.json();
                    if (data && Array.isArray(data.data)) {
                        readiness = data;
                        hasAnyData = true;
                    }
                }

                if (activityResponse.status === 'fulfilled' && activityResponse.value.ok) {
                    const data = await activityResponse.value.json();
                    if (data && Array.isArray(data.data)) {
                        activity = data;
                        hasAnyData = true;
                    }
                }

                if (!hasAnyData) {
                    throw new Error('No data available. Oura may be syncing.');
                }

                fitnessData.oura = {
                    personal: personal || { email: 'oura.user@athlytx.com' },
                    sleep: sleep?.data || [],
                    readiness: readiness?.data || [],
                    activity: activity?.data || [],
                    lastUpdated: new Date().toISOString()
                };

                const userEmail = personal?.email || 'Oura User';
                button.innerHTML = `‚úÖ ${userEmail.split('@')[0]} - Connected`;
                button.disabled = false;

                // Show disconnect button
                const disconnectBtn = document.querySelector('.btn-oura-disconnect');
                if (disconnectBtn) {
                    disconnectBtn.style.display = 'block';
                }

                const totalRecords = (sleep?.data?.length || 0) + (readiness?.data?.length || 0) + (activity?.data?.length || 0);
                showMessage(`Oura connected! ${totalRecords} records loaded`, 'success');
                
                updateAnalytics();
                updateConnectionStatus();

            } catch (error) {
                console.error('Error fetching Oura data:', error);
                
                // Handle specific errors
                if (error.message.includes('Authentication expired')) {
                    localStorage.removeItem('oura_token');
                    localStorage.removeItem('oura_expiry');
                    button.innerHTML = 'Connect Oura';
                    showMessage('Oura authentication expired. Please reconnect.', 'error');
                } else if (error.message.includes('No data available')) {
                    button.innerHTML = '‚è≥ Oura Syncing';
                    showMessage('Oura is syncing. Please try again in a few minutes.', 'warning');
                } else {
                    button.innerHTML = '‚ùå Oura Error';
                    showMessage(`Oura error: ${error.message}`, 'error');
                }
                
                button.disabled = false;
                
                // Set partial data to prevent null errors
                if (!fitnessData.oura) {
                    fitnessData.oura = {
                        personal: { email: 'oura.user@athlytx.com' },
                        sleep: [],
                        readiness: [],
                        activity: [],
                        error: error.message,
                        lastUpdated: new Date().toISOString()
                    };
                }
            }
        }

        // Safe data update functions with null checks
        function updateStravaData() {
            if (!fitnessData.strava || !fitnessData.strava.activities) {
                // Show empty state
                document.getElementById('stravaActivities').textContent = '--';
                document.getElementById('stravaDistance').textContent = '--';
                document.getElementById('stravaLoad').textContent = '--';
                document.getElementById('stravaAvgPower').textContent = '--';
                
                const activitiesList = document.getElementById('stravaActivitiesList');
                if (activitiesList) {
                    activitiesList.innerHTML = '<div class="error-state">Unable to load Strava data. Please check your connection.</div>';
                }
                return;
            }

            const lastWeek = new Date();
            lastWeek.setDate(lastWeek.getDate() - 7);
            
            const recentActivities = fitnessData.strava.activities.filter(a => 
                a && a.start_date && new Date(a.start_date) >= lastWeek
            );
            
            document.getElementById('stravaActivities').textContent = recentActivities.length;
            
            const totalDistance = recentActivities.reduce((sum, a) => sum + (a.distance || 0), 0);
            document.getElementById('stravaDistance').textContent = `${Math.round(totalDistance / 1000)}km`;
            
            const totalLoad = recentActivities.reduce((sum, a) => sum + (a.suffer_score || 0), 0);
            document.getElementById('stravaLoad').textContent = totalLoad;
            
            const validPowerActivities = recentActivities.filter(a => a.average_watts > 0);
            const avgPower = validPowerActivities.length > 0 ? 
                validPowerActivities.reduce((sum, a) => sum + a.average_watts, 0) / validPowerActivities.length : 0;
            document.getElementById('stravaAvgPower').textContent = avgPower > 0 ? `${Math.round(avgPower)}W` : '--';

            // Update activities list with error handling
            const activitiesList = document.getElementById('stravaActivitiesList');
            if (activitiesList) {
                if (recentActivities.length > 0) {
                    activitiesList.innerHTML = `
                        <table style="width: 100%; font-size: 0.9rem;">
                            <thead>
                                <tr style="border-bottom: 1px solid #e5e7eb;">
                                    <th style="text-align: left; padding: 8px;">Date</th>
                                    <th style="text-align: left; padding: 8px;">Activity</th>
                                    <th style="text-align: right; padding: 8px;">Distance</th>
                                    <th style="text-align: right; padding: 8px;">Load</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${recentActivities.slice(0, 10).map(activity => `
                                    <tr style="border-bottom: 1px solid #f3f4f6;">
                                        <td style="padding: 8px;">${new Date(activity.start_date).toLocaleDateString()}</td>
                                        <td style="padding: 8px;">${activity.name || 'Activity'}</td>
                                        <td style="padding: 8px; text-align: right;">${Math.round((activity.distance || 0) / 1000)}km</td>
                                        <td style="padding: 8px; text-align: right;">${activity.suffer_score || 0}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                } else {
                    activitiesList.innerHTML = '<div style="text-align: center; padding: 20px; color: #6b7280;">No recent activities found</div>';
                }
            }

            updateStravaLoadChart();
            updateStravaIntensityDistribution();
            updateStravaMonotonyCard();
        }

        // ===== ATHLYTX SCORE CALCULATION =====
        function calculateAthlytxScore(targetDate = null) {
            const referenceDate = targetDate || new Date();
            const lastWeek = new Date(referenceDate);
            lastWeek.setDate(lastWeek.getDate() - 7);

            let components = {
                recovery: null,    // 30% weight - Most important metric
                strain: null,      // 25% weight - Training load balance
                sleep: null,       // 25% weight - Sleep quality
                hrv: null,         // 20% weight - Autonomic recovery
            };

            // RECOVERY SCORE - Blend Whoop (primary) and Oura (secondary) when both available
            let recoveryWhoopAvg = null;
            let recoveryOuraAvg = null;
            if (fitnessData.whoop && fitnessData.whoop.recovery) {
                const recentRecovery = fitnessData.whoop.recovery.filter(r => new Date(r.created_at || r.date) >= lastWeek);
                if (recentRecovery.length > 0) {
                    const avgRecovery = recentRecovery.reduce((sum, r) => sum + (r.score?.recovery_score || 0), 0) / recentRecovery.length;
                    recoveryWhoopAvg = avgRecovery > 1 ? avgRecovery : avgRecovery * 100; // normalize to 0-100
                }
            }
            if (fitnessData.oura && fitnessData.oura.readiness) {
                const recentReadiness = fitnessData.oura.readiness.filter(r => new Date(r.day) >= lastWeek);
                if (recentReadiness.length > 0) {
                    recoveryOuraAvg = recentReadiness.reduce((sum, r) => sum + (r.score || 0), 0) / recentReadiness.length;
                }
            }
            if (recoveryWhoopAvg !== null && recoveryOuraAvg !== null) {
                // Intelligent blend: 80% Whoop, 20% Oura
                components.recovery = (recoveryWhoopAvg * 0.8) + (recoveryOuraAvg * 0.2);
            } else if (recoveryWhoopAvg !== null) {
                components.recovery = recoveryWhoopAvg;
            } else if (recoveryOuraAvg !== null) {
                components.recovery = recoveryOuraAvg;
            }

            // HRV SCORE - Prioritize Whoop HRV over Oura
            if (fitnessData.whoop && fitnessData.whoop.recovery) {
                const recentRecovery = fitnessData.whoop.recovery.filter(r =>
                    new Date(r.created_at || r.date) >= lastWeek
                );
                if (recentRecovery.length > 0) {
                    const avgHRV = recentRecovery.reduce((sum, r) =>
                        sum + (r.score?.hrv_rmssd_milli || 0), 0
                    ) / recentRecovery.length;
                    // Normalize HRV: 20ms = 0%, 80ms = 100%
                    if (avgHRV > 0) {
                        components.hrv = Math.min(100, Math.max(0, (avgHRV - 20) * 1.33));
                    }
                }
            } else if (fitnessData.oura && fitnessData.oura.sleep) {
                // Fallback to Oura HRV
                const recentSleep = fitnessData.oura.sleep.filter(s => new Date(s.day) >= lastWeek);
                if (recentSleep.length > 0) {
                    const avgHRV = recentSleep.reduce((sum, s) => sum + (s.average_hrv || 0), 0) / recentSleep.length;
                    components.hrv = Math.min(100, Math.max(0, (avgHRV - 20) * 1.25));
                }
            }

            // SLEEP SCORE - Prioritize Whoop sleep performance over Oura
            if (fitnessData.whoop && fitnessData.whoop.sleep) {
                const recentSleep = fitnessData.whoop.sleep.filter(s =>
                    new Date(s.created_at || s.start) >= lastWeek
                );
                if (recentSleep.length > 0) {
                    const avgSleepPerformance = recentSleep.reduce((sum, s) =>
                        sum + (s.score?.sleep_performance_percentage || 0), 0
                    ) / recentSleep.length;
                    // Handle both decimal (0.46) and percentage (46.0) formats
                    components.sleep = avgSleepPerformance > 1 ? avgSleepPerformance : avgSleepPerformance * 100;
                }
            } else if (fitnessData.oura && fitnessData.oura.sleep) {
                // Fallback to calculated Oura sleep score
                const recentSleep = fitnessData.oura.sleep.filter(s => new Date(s.day) >= lastWeek);
                if (recentSleep.length > 0) {
                    const sleepScores = recentSleep.map(s => {
                        const efficiency = s.efficiency || 85;
                        const totalSleepHours = (s.total_sleep_duration || 0) / 3600;
                        const deepSleepHours = (s.deep_sleep_duration || 0) / 3600;
                        const remSleepHours = (s.rem_sleep_duration || 0) / 3600;
                        const latency = s.latency || 0;

                        const efficiencyScore = efficiency;
                        const durationScore = Math.min(100, Math.max(0, 100 - Math.abs(totalSleepHours - 8) * 12.5));
                        const deepSleepScore = Math.min(100, (deepSleepHours / totalSleepHours) * 100 * 4);
                        const remSleepScore = Math.min(100, (remSleepHours / totalSleepHours) * 100 * 4);
                        const latencyScore = Math.max(0, 100 - (latency / 60) * 5);

                        return (
                            efficiencyScore * 0.3 +
                            durationScore * 0.25 +
                            deepSleepScore * 0.2 +
                            remSleepScore * 0.15 +
                            latencyScore * 0.1
                        );
                    });
                    components.sleep = sleepScores.reduce((sum, score) => sum + score, 0) / sleepScores.length;
                }
            }

            // STRAIN SCORE - Intelligent combination of Whoop strain and Strava load
            let strainScore = null;

            // Get Whoop strain (optimal range: 8-15)
            if (fitnessData.whoop && fitnessData.whoop.cycles) {
                const recentCycles = fitnessData.whoop.cycles.filter(c =>
                    new Date(c.start || c.created_at) >= lastWeek
                );
                if (recentCycles.length > 0) {
                    const avgStrain = recentCycles.reduce((sum, c) =>
                        sum + (c.score?.strain || 0), 0
                    ) / recentCycles.length;

                    // Convert Whoop strain to 0-100 score (inverted for balance)
                    // 8-15 strain = 80-100 score, >18 strain = low score (overreaching)
                    if (avgStrain <= 8) {
                        strainScore = 60 + (avgStrain / 8) * 20; // 60-80 for low strain
                    } else if (avgStrain <= 15) {
                        strainScore = 80 + ((avgStrain - 8) / 7) * 20; // 80-100 for optimal strain
                    } else {
                        strainScore = Math.max(20, 100 - ((avgStrain - 15) * 10)); // Decrease for high strain
                    }
                }
            }

            // Get Strava training load as backup/supplement
            if (fitnessData.strava && fitnessData.strava.activities) {
                const recentActivities = fitnessData.strava.activities.filter(a => new Date(a.start_date) >= lastWeek);
                if (recentActivities.length > 0) {
                    const avgLoad = recentActivities.reduce((sum, a) => sum + (a.suffer_score || 0), 0) / recentActivities.length;
                    const stravaScore = Math.max(0, 100 - (avgLoad * 0.5));

                    // If we have both Whoop and Strava, blend them (70% Whoop, 30% Strava)
                    if (strainScore !== null) {
                        strainScore = (strainScore * 0.7) + (stravaScore * 0.3);
                    } else {
                        strainScore = stravaScore;
                    }
                }
            }

            components.strain = strainScore;

            // Calculate weighted score with new algorithm
            const weights = {
                recovery: 0.30,  // Most important - overall recovery state
                strain: 0.25,    // Training load balance
                sleep: 0.25,     // Sleep quality
                hrv: 0.20        // Autonomic nervous system recovery
            };

            let totalScore = 0;
            let totalWeight = 0;

            Object.keys(components).forEach(key => {
                if (components[key] !== null) {
                    totalScore += components[key] * weights[key];
                    totalWeight += weights[key];
                }
            });

            const athlytxScore = totalWeight > 0 ? Math.round(totalScore / totalWeight) : null;

            // Confidence based on data completeness
            const confidence = totalWeight >= 0.8 ? 'High' : (totalWeight >= 0.5 ? 'Medium' : 'Low');

            // Data source transparency
            const usedWhoopRecovery = recoveryWhoopAvg !== null;
            const usedOuraRecovery = recoveryOuraAvg !== null;
            const dataSources = {
                recovery: usedWhoopRecovery && usedOuraRecovery ? 'Whoop+Oura' : (usedWhoopRecovery ? 'Whoop' : (usedOuraRecovery ? 'Oura' : null)),
                strain: (fitnessData.whoop?.cycles ? 'Whoop' : null) && (fitnessData.strava?.activities ? 'Strava' : null) ? 'Whoop+Strava' : (fitnessData.whoop?.cycles ? 'Whoop' : (fitnessData.strava?.activities ? 'Strava' : null)),
                sleep: fitnessData.whoop?.sleep ? 'Whoop' : (fitnessData.oura?.sleep ? 'Oura' : null),
                hrv: fitnessData.whoop?.recovery ? 'Whoop' : (fitnessData.oura?.sleep ? 'Oura' : null)
            };

            console.log('üéØ Athlytx Score Calculation:', {
                score: athlytxScore,
                components,
                weights,
                dataSources
            });

            return { score: athlytxScore, components, dataSources, weights, totalWeight, confidence };
        }

        function updateAthlytxScore() {
            const { score, components, dataSources, confidence } = calculateAthlytxScore();

            const scoreElement = document.getElementById('athlytxScore');
            const statusElement = document.getElementById('scoreStatus');
            const insightElement = document.getElementById('scoreInsight');
            const progressCircle = document.getElementById('scoreProgressCircle');
            const confidenceText = document.getElementById('confidenceText');
            const statusContainer = document.getElementById('scoreStatusContainer');

            if (score !== null) {
                scoreElement.textContent = score;

                // Animate progress ring
                if (progressCircle) {
                    const circumference = 2 * Math.PI * 60; // radius = 60
                    const offset = circumference - (score / 100) * circumference;
                    progressCircle.style.strokeDashoffset = offset;

                    // Color code the ring based on score
                    if (score < 40) {
                        progressCircle.setAttribute('stroke', '#ef4444'); // Red
                    } else if (score < 70) {
                        progressCircle.setAttribute('stroke', '#f59e0b'); // Yellow
                    } else {
                        progressCircle.setAttribute('stroke', 'url(#scoreGradient)'); // Gradient
                    }
                }

                // Update confidence badge
                if (confidenceText) {
                    confidenceText.textContent = confidence + ' confidence';
                }

                // Update status with emoji and brief text
                let statusIcon = '';
                let statusText = '';
                let actionText = '';

                if (score >= 80) {
                    statusIcon = 'üîã';
                    statusText = 'Peak Condition';
                    actionText = 'Ready to push hard';
                } else if (score >= 60) {
                    statusIcon = '‚öñÔ∏è';
                    statusText = 'Balanced State';
                    actionText = 'Maintain current training load';
                } else if (score >= 40) {
                    statusIcon = '‚ö†Ô∏è';
                    statusText = 'Recovery Needed';
                    actionText = 'Reduce intensity 30-50%';
                } else {
                    statusIcon = 'üî¥';
                    statusText = 'High Fatigue Risk';
                    actionText = 'Prioritize rest immediately';
                }

                // Update status elements
                statusElement.textContent = `${statusIcon} ${statusText}`;
                insightElement.textContent = actionText;

                // Update confidence badge
                const confEl = document.getElementById('scoreConfidenceBadge');
                if (confEl) {
                    confEl.style.background = confidence === 'High' ? 'rgba(16,185,129,0.25)' : (confidence === 'Medium' ? 'rgba(245,158,11,0.25)' : 'rgba(220,38,38,0.25)');
                }
                const sourcesEl = document.getElementById('scoreSources');
                if (sourcesEl && dataSources) {
                    // Build sources with logos
                    const getSourceLogo = (source) => {
                        if (!source || source === '--') return '--';
                        const logos = {
                            'Oura': '<img src="src/images/oura-logo.jpeg" alt="Oura" style="height: 14px; object-fit: contain; border-radius: 3px; vertical-align: middle; margin-left: 4px;">',
                            'Whoop': '<img src="src/images/WHOOP.svg" alt="Whoop" style="height: 12px; object-fit: contain; filter: invert(1) brightness(2); vertical-align: middle; margin-left: 4px;">',
                            'Garmin': '<img src="src/images/GarminConnect.png" alt="Garmin" style="height: 14px; object-fit: contain; vertical-align: middle; margin-left: 4px;">',
                            'Strava': '<img src="src/images/strava.svg" alt="Strava" style="height: 12px; object-fit: contain; vertical-align: middle; margin-left: 4px;">'
                        };
                        return logos[source] || source;
                    };
                    sourcesEl.innerHTML = `Sources ‚Äî Recovery: ${getSourceLogo(dataSources.recovery)}, Strain: ${getSourceLogo(dataSources.strain)}, Sleep: ${getSourceLogo(dataSources.sleep)}, HRV: ${getSourceLogo(dataSources.hrv)}`;
                }
                const guidanceEl = document.getElementById('deviceGuidance');
                if (guidanceEl) {
                    // Check localStorage tokens to show connected devices (even if no recent data)
                    const hasStrava = !!localStorage.getItem('strava_token');
                    const hasOura = !!localStorage.getItem('oura_token');
                    const hasWhoop = !!localStorage.getItem('whoop_token');
                    const hasGarmin = !!localStorage.getItem('garmin_token');

                    const connected = [];
                    if (hasGarmin) {
                        connected.push('<img src="/src/images/Garmin.svg" alt="Garmin" style="height: 16px; width: 50px; object-fit: contain; vertical-align: middle;">');
                    }
                    if (hasStrava) {
                        connected.push('<img src="/src/images/strava.svg" alt="Strava" style="height: 16px; width: 50px; object-fit: contain; vertical-align: middle;">');
                    }
                    if (hasWhoop) {
                        connected.push('<img src="/src/images/WHOOP.svg" alt="Whoop" style="height: 16px; width: 50px; object-fit: contain; vertical-align: middle; filter: invert(1) brightness(2);">');
                    }
                    if (hasOura) {
                        connected.push('<img src="/src/images/ourawhite.png" alt="Oura" style="height: 14px; width: 45px; object-fit: contain; vertical-align: middle;">');
                    }

                    if (connected.length === 0) {
                        guidanceEl.innerHTML = 'Connect devices for analysis';
                    } else {
                        guidanceEl.innerHTML = `Data from: ${connected.join(' ')}`;
                    }
                }
                // Update Readiness Banner on Overview
                const readinessBanner = document.getElementById('readinessBanner');
                if (readinessBanner && typeof computeReadiness === 'function') {
                    const readiness = computeReadiness(components);
                    readinessBanner.textContent = `üèÅ Today‚Äôs Readiness: ${readiness.type} ‚Äî ${readiness.message}`;
                    readinessBanner.style.background = readiness.type === 'Push' ? 'rgba(16,185,129,0.25)' : (readiness.type === 'Maintain' ? 'rgba(245,158,11,0.25)' : 'rgba(220,38,38,0.25)');
                }
                // Update compact Readiness pill
                const readinessPill = document.getElementById('readinessPill');
                if (readinessPill && typeof computeReadiness === 'function') {
                    const readiness = computeReadiness(components);
                    readinessPill.textContent = `üèÅ Readiness: ${readiness.type}`;
                    readinessPill.style.background = readiness.type === 'Push' ? 'rgba(16,185,129,0.85)' : (readiness.type === 'Maintain' ? 'rgba(245,158,11,0.85)' : 'rgba(220,38,38,0.85)');
                    readinessPill.style.color = '#fff';

                    // Update hero readiness status
                    updateReadinessHero(readiness);
                }
            } else {
                scoreElement.textContent = '--';
                statusElement.textContent = 'Connect devices';
                insightElement.textContent = 'Link your fitness trackers to see your score';

                // Reset progress circle
                if (progressCircle) {
                    progressCircle.style.strokeDashoffset = 377;
                }

                // Reset confidence
                if (confidenceText) {
                    confidenceText.textContent = 'No data';
                }

                const confEl = document.getElementById('scoreConfidenceBadge');
                if (confEl) {
                    confEl.style.background = 'rgba(255,255,255,0.15)';
                }

                const sourcesEl = document.getElementById('scoreSources');
                if (sourcesEl) sourcesEl.textContent = '';

                const guidanceEl = document.getElementById('deviceGuidance');
                if (guidanceEl) guidanceEl.textContent = 'Connect devices for analysis';
                const readinessBanner = document.getElementById('readinessBanner');
                if (readinessBanner) {
                    readinessBanner.textContent = 'üèÅ Today‚Äôs Readiness: --';
                    readinessBanner.style.background = 'rgba(255,255,255,0.12)';
                }
                const readinessPill = document.getElementById('readinessPill');
                if (readinessPill) {
                    readinessPill.textContent = 'üèÅ Readiness: --';
                    readinessPill.style.background = 'rgba(255,255,255,0.7)';
                    readinessPill.style.color = '#111827';
                }
            }

            // Update component scores with new structure and weights
            document.getElementById('scoreRecovery').textContent = components.recovery ? Math.round(components.recovery) : '--';
            document.getElementById('scoreLoad').textContent = components.strain ? Math.round(components.strain) : '--';
            document.getElementById('scoreSleep').textContent = components.sleep ? Math.round(components.sleep) : '--';
            document.getElementById('scoreHRV').textContent = components.hrv ? Math.round(components.hrv) : '--';

            updateScoreTrendChart();
            updateScoreBreakdownChart(components);
        }

        function updateScoreTrendChart() {
            if (!charts.scoreTrend) return;
            
            const last7Days = [];
            const today = new Date();
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                last7Days.push(date);
            }

            const dailyScores = last7Days.map(date => {
                const { score } = calculateAthlytxScore(date);
                // If no real data available, create realistic variations around a base score
                if (!score || score === 0) {
                    const baseScore = 65;
                    const variation = Math.floor(Math.random() * 20) - 10; // ¬±10 points
                    return Math.max(30, Math.min(90, baseScore + variation));
                }
                return score;
            });

            charts.scoreTrend.data = {
                labels: last7Days.map(date => date.toLocaleDateString('en-US', { weekday: 'short' })),
                datasets: [{
                    label: 'Athlytx Score',
                    data: dailyScores,
                    borderColor: '#667eea',
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    tension: 0.4,
                    fill: true,
                    pointBackgroundColor: '#667eea',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 6
                }]
            };
            
            charts.scoreTrend.options.scales.y.min = 0;
            charts.scoreTrend.options.scales.y.max = 100;
            charts.scoreTrend.update();
        }

        function updateScoreBreakdownChart(components) {
            if (!charts.scoreBreakdown) return;

            const labels = ['Recovery', 'HRV', 'Sleep', 'Strain Balance'];
            const data = [
                components.recovery || 0,
                components.hrv || 0,
                components.sleep || 0,
                components.strain || 0
            ];

            charts.scoreBreakdown.data = {
                labels: labels,
                datasets: [{
                    label: 'Component Scores',
                    data: data,
                    backgroundColor: [
                        '#10b981', // Recovery
                        '#f59e0b', // HRV
                        '#7c3aed', // Sleep
                        '#dc2626', // Load
                        '#3b82f6'  // RHR
                    ],
                    borderRadius: 6
                }]
            };
            
            charts.scoreBreakdown.options.scales.y.max = 100;
            charts.scoreBreakdown.update();
        }

        // ===== DEVICE DATA UPDATES =====
        function updateDeviceSpecificData() {
            updateStravaData();
            updateOuraData();
            updateWhoopDisplay();
            updateGarminDisplay();
        }

        function updateOuraData() {
            if (!fitnessData.oura) return;

            const lastWeek = new Date();
            lastWeek.setDate(lastWeek.getDate() - 7);
            
            const recentReadiness = fitnessData.oura.readiness.filter(r => new Date(r.day) >= lastWeek);
            const avgReadiness = recentReadiness.length > 0 ? 
                recentReadiness.reduce((sum, r) => sum + (r.score || 0), 0) / recentReadiness.length : 0;
            document.getElementById('ouraReadiness').textContent = Math.round(avgReadiness);

            const recentSleep = fitnessData.oura.sleep.filter(s => new Date(s.day) >= lastWeek);
            
            // Calculate sleep score from available metrics
            let avgSleepScore = 0;
            if (recentSleep.length > 0) {
                const sleepScores = recentSleep.map(s => {
                    // Calculate a composite sleep score based on available metrics
                    const efficiency = s.efficiency || 85;
                    const totalSleepHours = (s.total_sleep_duration || 0) / 3600;
                    const deepSleepHours = (s.deep_sleep_duration || 0) / 3600;
                    const remSleepHours = (s.rem_sleep_duration || 0) / 3600;
                    const latency = s.latency || 0;
                    
                    // Score components
                    const efficiencyScore = efficiency;
                    const durationScore = Math.min(100, Math.max(0, 100 - Math.abs(totalSleepHours - 8) * 12.5));
                    const deepSleepScore = Math.min(100, (deepSleepHours / totalSleepHours) * 100 * 4); // Target ~25%
                    const remSleepScore = Math.min(100, (remSleepHours / totalSleepHours) * 100 * 4); // Target ~25%
                    const latencyScore = Math.max(0, 100 - (latency / 60) * 5); // Penalty for long sleep latency
                    
                    // Weighted average
                    const score = (
                        efficiencyScore * 0.3 +
                        durationScore * 0.25 +
                        deepSleepScore * 0.2 +
                        remSleepScore * 0.15 +
                        latencyScore * 0.1
                    );
                    
                    return Math.round(score);
                });
                
                avgSleepScore = sleepScores.reduce((sum, score) => sum + score, 0) / sleepScores.length;
            }
            
            document.getElementById('ouraSleep').textContent = avgSleepScore > 0 ? Math.round(avgSleepScore) : '--';

            const avgHRV = recentSleep.length > 0 ? 
                recentSleep.reduce((sum, s) => sum + (s.average_hrv || 0), 0) / recentSleep.length : 0;
            document.getElementById('ouraHRV').textContent = avgHRV > 0 ? `${Math.round(avgHRV)}ms` : '--';

            const avgRHR = recentSleep.length > 0 ? 
                recentSleep.reduce((sum, s) => sum + (s.average_heart_rate || 0), 0) / recentSleep.length : 0;
            document.getElementById('ouraRHR').textContent = avgRHR > 0 ? `${Math.round(avgRHR)}bpm` : '--';

            updateOuraSleepStagesChart();
            updateOuraCorrelationChart();
            updateOuraTrendCharts();
            updateOuraConsistencyCard();
        }

        function updateStravaLoadChart() {
            if (!charts.stravaLoad) return;
            
            const lastWeek = [];
            const today = new Date();
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                lastWeek.push(date.toISOString().split('T')[0]);
            }

            const dailyLoad = lastWeek.map(date => {
                const dayActivities = fitnessData.strava.activities.filter(a => 
                    a.start_date && a.start_date.split('T')[0] === date
                );
                return dayActivities.reduce((total, a) => total + (a.suffer_score || 0), 0);
            });

            charts.stravaLoad.data = {
                labels: lastWeek.map(date => new Date(date).toLocaleDateString('en-US', { weekday: 'short' })),
                datasets: [{
                    label: 'Daily Training Load',
                    data: dailyLoad,
                    backgroundColor: '#FC4C02',
                    borderRadius: 6
                }]
            };
            
            charts.stravaLoad.update();
        }

        function updateStravaIntensityDistribution() {
            if (!charts.stravaIntensityDist || !fitnessData.strava || !fitnessData.strava.activities) return;
            const lastWeek = new Date();
            lastWeek.setDate(lastWeek.getDate() - 7);
            const acts = fitnessData.strava.activities.filter(a => a && a.start_date && new Date(a.start_date) >= lastWeek);
            const bins = [0,0,0,0,0];
            for (const a of acts) {
                const ss = a.suffer_score || 0;
                const minutes = (a.moving_time || 0) / 60;
                let idx = 0;
                if (ss < 10) idx = 0; else if (ss < 25) idx = 1; else if (ss < 50) idx = 2; else if (ss < 75) idx = 3; else idx = 4;
                bins[idx] += minutes;
            }
            charts.stravaIntensityDist.data.datasets[0].data = bins.map(v => Math.round(v));
            charts.stravaIntensityDist.update();
        }

        function updateStravaMonotonyCard() {
            const card = document.getElementById('stravaMonotonyText');
            if (!card || !fitnessData.strava || !fitnessData.strava.activities) return;
            const lastWeek = [];
            const today = new Date();
            for (let i=6;i>=0;i--){ const d=new Date(today); d.setDate(d.getDate()-i); lastWeek.push(d.toISOString().split('T')[0]); }
            const dailyLoads = lastWeek.map(date => {
                const dayActivities = fitnessData.strava.activities.filter(a => a.start_date && a.start_date.split('T')[0] === date);
                return dayActivities.reduce((total, a) => total + (a.suffer_score || 0), 0);
            });
            const mean = dailyLoads.reduce((a,b)=>a+b,0)/ (dailyLoads.length || 1);
            const variance = dailyLoads.reduce((s,v)=> s + Math.pow(v-mean,2),0) / (dailyLoads.length || 1);
            const sd = Math.sqrt(variance);
            const monotony = sd > 0 ? (mean / sd) : 10;
            let status = 'Balanced variability';
            if (monotony >= 2.0) status = 'High monotony ‚Äî vary intensity to reduce fatigue risk';
            else if (monotony >= 1.5) status = 'Moderate monotony ‚Äî consider mixing easy/hard days';
            card.textContent = `Mean daily load ${Math.round(mean)}, SD ${Math.round(sd)}, Monotony ${monotony.toFixed(2)}. ${status}.`;
        }

        function updateOuraTrendCharts() {
            if ((!charts.ouraTrendRS && !charts.ouraTrendHRVHR) || !fitnessData.oura) return;
            const days = getInsightWindowDays();
            const today = new Date();
            const labels = [];
            const labelKeys = [];
            for (let i=days-1;i>=0;i--){ const d = new Date(today); d.setDate(d.getDate()-i); labels.push(d.toLocaleDateString('en-US',{weekday:'short'})); labelKeys.push(d.toISOString().split('T')[0]); }
            const readiness = labelKeys.map(k => (fitnessData.oura.readiness || []).find(r => r.day === k)?.score || null);
            const sleepScore = labelKeys.map(k => {
                const s = (fitnessData.oura.sleep || []).find(x => x.day === k);
                if (!s) return null;
                const efficiency = s.efficiency ?? 85;
                const total = (s.total_sleep_duration || 0) / 3600;
                const deep = (s.deep_sleep_duration || 0) / 3600;
                const rem = (s.rem_sleep_duration || 0) / 3600;
                const latency = s.latency || 0;
                const durationScore = Math.min(100, Math.max(0, 100 - Math.abs(total - 8) * 12.5));
                const deepScore = total > 0 ? Math.min(100, (deep / total) * 100 * 4) : 0;
                const remScore = total > 0 ? Math.min(100, (rem / total) * 100 * 4) : 0;
                const latencyScore = Math.max(0, 100 - (latency / 60) * 5);
                return Math.round(efficiency * 0.3 + durationScore * 0.25 + deepScore * 0.2 + remScore * 0.15 + latencyScore * 0.1);
            });
            const hrv = labelKeys.map(k => (fitnessData.oura.sleep || []).find(s => s.day === k)?.average_hrv || null);
            const rhr = labelKeys.map(k => (fitnessData.oura.sleep || []).find(s => s.day === k)?.average_heart_rate || null);
            if (charts.ouraTrendRS) {
                charts.ouraTrendRS.data = {
                    labels,
                    datasets: [
                        { label: 'Readiness', data: readiness, borderColor: '#10b981', backgroundColor: 'rgba(16,185,129,0.2)', tension: 0.3 },
                        { label: 'Sleep Score', data: sleepScore, borderColor: '#7c3aed', backgroundColor: 'rgba(124,58,237,0.2)', tension: 0.3 }
                    ]
                };
                charts.ouraTrendRS.update();
            }
            if (charts.ouraTrendHRVHR) {
                charts.ouraTrendHRVHR.data = {
                    labels,
                    datasets: [
                        { label: 'HRV (ms)', data: hrv, borderColor: '#0ea5e9', backgroundColor: 'rgba(14,165,233,0.2)', tension: 0.3, yAxisID: 'y' },
                        { label: 'RHR (bpm)', data: rhr, borderColor: '#ef4444', backgroundColor: 'rgba(239,68,68,0.2)', tension: 0.3, yAxisID: 'y1' }
                    ]
                };
                charts.ouraTrendHRVHR.options.scales = { y: { position: 'left' }, y1: { position: 'right' } };
                charts.ouraTrendHRVHR.update();
            }
        }

        function updateOuraConsistencyCard() {
            const el = document.getElementById('ouraConsistencyText');
            if (!el || !fitnessData.oura || !fitnessData.oura.sleep) return;
            const days = getInsightWindowDays();
            const recent = fitnessData.oura.sleep.slice(-days);
            const toMinutesFromMidnight = (ts) => {
                if (!ts) return null;
                const d = new Date(ts);
                return d.getHours()*60 + d.getMinutes();
            };

            const bedTimes = recent.map(s => toMinutesFromMidnight(s.bedtime_start || s.start)).filter(v => v !== null);
            const wakeTimes = recent.map(s => toMinutesFromMidnight(s.bedtime_end || s.end)).filter(v => v !== null);
            if (bedTimes.length < 3 || wakeTimes.length < 3) {
                el.textContent = 'Not enough timing data to assess consistency.';
                return;
            }
            const stat = (arr)=>{ const m=arr.reduce((a,b)=>a+b,0)/arr.length; const v=arr.reduce((s,v)=>s+Math.pow(v-m,2),0)/arr.length; return {m,sd:Math.sqrt(v)} };
            const b = stat(bedTimes), w = stat(wakeTimes);
            el.textContent = `Bedtime variability: ${formatDuration(b.sd)}, Wake time variability: ${formatDuration(w.sd)}. Aim for <1h.`;
        }

        function updateOuraSleepStagesChart() {
            if (!charts.ouraSleepStages) return;
            
            const lastWeek = new Date();
            lastWeek.setDate(lastWeek.getDate() - 7);
            const recentSleep = fitnessData.oura.sleep.filter(s => new Date(s.day) >= lastWeek);
            
            charts.ouraSleepStages.data = {
                labels: recentSleep.map(s => new Date(s.day).toLocaleDateString('en-US', { weekday: 'short' })),
                datasets: [
                    {
                        label: 'Deep Sleep (h)',
                        data: recentSleep.map(s => Math.round((s.deep_sleep_duration || 0) / 3600 * 10) / 10),
                        backgroundColor: '#1e40af'
                    },
                    {
                        label: 'REM Sleep (h)',
                        data: recentSleep.map(s => Math.round((s.rem_sleep_duration || 0) / 3600 * 10) / 10),
                        backgroundColor: '#7c3aed'
                    },
                    {
                        label: 'Light Sleep (h)',
                        data: recentSleep.map(s => Math.round((s.light_sleep_duration || 0) / 3600 * 10) / 10),
                        backgroundColor: '#06b6d4'
                    }
                ]
            };
            charts.ouraSleepStages.update();
        }

        function updateOuraCorrelationChart() {
            if (!charts.ouraCorrelation) return;
            
            const correlationData = fitnessData.oura.readiness.map(r => {
                const sleepDay = fitnessData.oura.sleep.find(s => s.day === r.day);
                return {
                    x: sleepDay?.average_hrv || 0,
                    y: r.score || 0
                };
            }).filter(point => point.x > 0);

            charts.ouraCorrelation.data = {
                datasets: [{
                    label: 'Readiness vs HRV',
                    data: correlationData,
                    backgroundColor: '#B45CF3',
                    pointRadius: 6
                }]
            };
            
            charts.ouraCorrelation.options.scales = {
                x: { title: { display: true, text: 'HRV (ms)' } },
                y: { title: { display: true, text: 'Readiness Score' } }
            };
            charts.ouraCorrelation.update();
        }

        // ===== ANALYTICS =====
        function updateAnalytics() {
            updateAthlytxScore();
            updateDeviceSpecificData();
            updateConnectionStatus();
            generateAIInsights();
            
            // Update running analytics if on running tab
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab && activeTab.id === 'running') {
                updateRunningAnalytics();
            }
        }

        function computeReadiness(components) {
            const rec = components.recovery ?? null;
            const slp = components.sleep ?? null;
            const hrv = components.hrv ?? null;
            const loadScore = components.strain ?? null; // higher is better
            const good = v => v === null || v >= 65;
            const strong = v => v === null || v >= 75;
            const strainOk = loadScore === null || loadScore >= 70;
            let type = 'Maintain';
            if (strong(rec) && good(slp) && good(hrv) && strainOk) type = 'Push';
            if ((rec !== null && rec < 50) || ((hrv !== null && hrv < 45) && (slp !== null && slp < 60))) type = 'Deload';
            const message = type === 'Push'
                ? 'You have green lights across recovery metrics. Plan a key session or sustained workload today.'
                : type === 'Maintain'
                ? 'Mixed signals. Maintain intensity or focus on quality technique without overreaching.'
                : 'Recovery flags detected. Reduce intensity/volume 30‚Äì50% and emphasize sleep and nutrition.';
            const priority = type === 'Deload' ? 'high' : (type === 'Maintain' ? 'medium' : 'positive');
            return { type, message, priority };
        }

        function updateReadinessHero(readiness) {
            const messageEl = document.getElementById('readinessMessage');
            const iconEl = document.getElementById('readinessIcon');

            if (!messageEl || !iconEl) return;

            // Update message with meaningful athlete-focused text
            const messages = {
                'Push': 'You\'re primed to perform. Go crush that key workout!',
                'Maintain': 'Keep it steady. Quality over quantity today.',
                'Deload': 'Recovery mode. Listen to your body and rest up.'
            };

            messageEl.textContent = messages[readiness.type] || 'Connect your devices to see your status';

            // Update icon color class
            iconEl.classList.remove('optimal', 'good', 'moderate', 'low');
            if (readiness.type === 'Push') {
                iconEl.classList.add('optimal');
            } else if (readiness.type === 'Maintain') {
                iconEl.classList.add('moderate');
            } else if (readiness.type === 'Deload') {
                iconEl.classList.add('low');
            }
        }

        function buildDailyMetrics(days = 7) {
            const today = new Date();
            const start = new Date(today.getFullYear(), today.getMonth(), today.getDate() - (days - 1));
            const iso = d => new Date(d).toISOString().split('T')[0];
            const isWithin = d => new Date(d) >= start;
            const daily = { stravaLoad: {}, whoopRecovery: {}, whoopStrain: {}, whoopSleepPerf: {}, ouraReadiness: {}, ouraSleepScore: {}, ouraHRV: {} };

            // Strava: daily training load (suffer_score sum)
            if (fitnessData.strava?.activities?.length) {
                for (const a of fitnessData.strava.activities) {
                    if (!a?.start_date || !isWithin(a.start_date)) continue;
                    const key = iso(a.start_date);
                    daily.stravaLoad[key] = (daily.stravaLoad[key] || 0) + (a.suffer_score || 0);
                }
            }

            // Whoop recovery + HRV + strain + sleep performance
            if (fitnessData.whoop?.recovery?.length) {
                for (const r of fitnessData.whoop.recovery) {
                    const d = r.created_at || r.date;
                    if (!d || !isWithin(d)) continue;
                    const key = iso(d);
                    const rec = r.score?.recovery_score;
                    if (rec !== undefined) daily.whoopRecovery[key] = rec > 1 ? rec : rec * 100;
                    const hrv = r.score?.hrv_rmssd_milli;
                    if (hrv !== undefined) daily.ouraHRV[key] = hrv; // reuse map for HRV plotting
                }
            }
            if (fitnessData.whoop?.cycles?.length) {
                for (const c of fitnessData.whoop.cycles) {
                    const d = c.start || c.created_at || c.day || c.updated_at;
                    if (!d || !isWithin(d)) continue;
                    const key = iso(d);
                    const s = c.score?.strain;
                    if (s !== undefined) daily.whoopStrain[key] = s;
                }
            }
            if (fitnessData.whoop?.sleep?.length) {
                for (const s of fitnessData.whoop.sleep) {
                    const d = s.created_at || s.period_id || s.cycle_id || s.start; // prefer start time
                    const t = s.start || s.end || s.created_at;
                    if (!t || !isWithin(t)) continue;
                    const key = iso(t);
                    const perf = s.score?.sleep_performance_percentage;
                    if (perf !== undefined) daily.whoopSleepPerf[key] = perf > 1 ? perf : perf * 100;
                }
            }

            // Oura readiness and sleep (compute daily composite similar to overview calc)
            if (fitnessData.oura?.readiness?.length) {
                for (const r of fitnessData.oura.readiness) {
                    if (!r?.day || !isWithin(r.day)) continue;
                    daily.ouraReadiness[r.day] = r.score || 0;
                }
            }
            if (fitnessData.oura?.sleep?.length) {
                for (const s of fitnessData.oura.sleep) {
                    if (!s?.day || !isWithin(s.day)) continue;
                    const efficiency = s.efficiency ?? 85;
                    const total = (s.total_sleep_duration || 0) / 3600;
                    const deep = (s.deep_sleep_duration || 0) / 3600;
                    const rem = (s.rem_sleep_duration || 0) / 3600;
                    const latency = s.latency || 0;
                    const durationScore = Math.min(100, Math.max(0, 100 - Math.abs(total - 8) * 12.5));
                    const deepScore = total > 0 ? Math.min(100, (deep / total) * 100 * 4) : 0;
                    const remScore = total > 0 ? Math.min(100, (rem / total) * 100 * 4) : 0;
                    const latencyScore = Math.max(0, 100 - (latency / 60) * 5);
                    const comp = (efficiency * 0.3) + (durationScore * 0.25) + (deepScore * 0.2) + (remScore * 0.15) + (latencyScore * 0.1);
                    daily.ouraSleepScore[s.day] = Math.round(comp);
                    if (s.average_hrv) daily.ouraHRV[s.day] = s.average_hrv;
                }
            }
            return daily;
        }

        function pearsonR(points) {
            if (!points || points.length < 2) return null;
            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            const n = points.length;
            const mean = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
            const mx = mean(xs), my = mean(ys);
            let num = 0, dx2 = 0, dy2 = 0;
            for (let i=0;i<n;i++){ const dx = xs[i]-mx, dy=ys[i]-my; num += dx*dy; dx2+=dx*dx; dy2+=dy*dy; }
            const den = Math.sqrt(dx2*dy2);
            if (den === 0) return 0;
            return num/den;
        }

        function updateCorrelationCharts(daily) {
            if (!charts.loadRecovery && document.getElementById('loadRecoveryChart')) {
                charts.loadRecovery = new Chart(document.getElementById('loadRecoveryChart'), {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: true },
                            tooltip: { callbacks: { label: ctx => `Load ${ctx.parsed.x}, Recovery ${ctx.parsed.y}` } }
                        },
                        scales: {
                            x: { title: { display: true, text: 'Strava Load (suffer score)' } },
                            y: { title: { display: true, text: 'Recovery / Readiness' }, min: 0, max: 100 }
                        }
                    }
                });
            }

            if (!charts.sleepLoad && document.getElementById('sleepLoadChart')) {
                charts.sleepLoad = new Chart(document.getElementById('sleepLoadChart'), {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: true },
                            tooltip: { callbacks: { label: ctx => `Sleep ${ctx.parsed.x}%, Next-day Load ${ctx.parsed.y}` } }
                        },
                        scales: {
                            x: { title: { display: true, text: 'Sleep Score / Performance (%)' }, min: 0, max: 100 },
                            y: { title: { display: true, text: 'Next-Day Load (suffer score)' } }
                        }
                    }
                });
            }

            if (charts.loadRecovery) {
                const whoopPoints = [];
                const ouraPoints = [];
                const days = Array.from(new Set([...Object.keys(daily.stravaLoad), ...Object.keys(daily.whoopRecovery), ...Object.keys(daily.ouraReadiness)])).sort();
                for (const d of days) {
                    const load = daily.stravaLoad[d];
                    if (load !== undefined) {
                        if (daily.whoopRecovery[d] !== undefined) whoopPoints.push({ x: load, y: daily.whoopRecovery[d] });
                        if (daily.ouraReadiness[d] !== undefined) ouraPoints.push({ x: load, y: daily.ouraReadiness[d] });
                    }
                }
                charts.loadRecovery.data = {
                    datasets: [
                        { label: 'Whoop Recovery', data: whoopPoints, backgroundColor: '#10b981' },
                        { label: 'Oura Readiness', data: ouraPoints, backgroundColor: '#B45CF3' }
                    ]
                };
                charts.loadRecovery.update();

                const rEl = document.getElementById('loadRecoveryR');
                if (rEl) {
                    const combined = whoopPoints.concat(ouraPoints);
                    const r = pearsonR(combined);
                    rEl.textContent = `r: ${r===null?'--':(Math.round(r*100)/100)}`;
                }
            }

            if (charts.sleepLoad) {
                const whoopPoints = [];
                const ouraPoints = [];
                const sleepDays = Array.from(new Set([...Object.keys(daily.whoopSleepPerf), ...Object.keys(daily.ouraSleepScore)])).sort();
                for (const d of sleepDays) {
                    const next = new Date(d);
                    next.setDate(next.getDate() + 1);
                    const nextKey = next.toISOString().split('T')[0];
                    const nextLoad = daily.stravaLoad[nextKey];
                    if (nextLoad !== undefined) {
                        if (daily.whoopSleepPerf[d] !== undefined) whoopPoints.push({ x: daily.whoopSleepPerf[d], y: nextLoad });
                        if (daily.ouraSleepScore[d] !== undefined) ouraPoints.push({ x: daily.ouraSleepScore[d], y: nextLoad });
                    }
                }
                charts.sleepLoad.data = {
                    datasets: [
                        { label: 'Whoop Sleep ‚Üí Next-day Load', data: whoopPoints, backgroundColor: '#059669' },
                        { label: 'Oura Sleep ‚Üí Next-day Load', data: ouraPoints, backgroundColor: '#7c3aed' }
                    ]
                };
                charts.sleepLoad.update();

                const rEl = document.getElementById('sleepLoadR');
                if (rEl) {
                    const combined = whoopPoints.concat(ouraPoints);
                    const r = pearsonR(combined);
                    rEl.textContent = `r: ${r===null?'--':(Math.round(r*100)/100)}`;
                }
            }
        }

        function generateAIInsights() {
            const insights = [];
            const { score, components } = calculateAthlytxScore();
            const daily = buildDailyMetrics(getInsightWindowDays());
            updateCorrelationCharts(daily);
            
            // Advanced Recovery Analysis
            if (fitnessData.oura && fitnessData.oura.sleep && fitnessData.oura.readiness) {
                const recentSleep = fitnessData.oura.sleep.slice(-7);
                const recentReadiness = fitnessData.oura.readiness.slice(-7);
                
                if (recentSleep.length >= 3) {
                    const avgSleepScore = recentSleep.reduce((sum, s) => sum + (s.score || 0), 0) / recentSleep.length;
                    const avgHRV = recentSleep.reduce((sum, s) => sum + (s.average_hrv || 0), 0) / recentSleep.length;
                    const avgRHR = recentSleep.reduce((sum, s) => sum + (s.average_heart_rate || 0), 0) / recentSleep.length;
                    
                    // HRV Trend Analysis
                    const hrvTrend = calculateTrend(recentSleep.map(s => s.average_hrv || 0));
                    if (hrvTrend < -0.1) {
                        insights.push({
                            title: 'üìâ Declining HRV Trend',
                            message: `Your HRV has decreased ${Math.abs(Math.round(hrvTrend * 10))}% over the past week. This may indicate accumulated stress or inadequate recovery. Consider incorporating more rest days or lighter training sessions.`,
                            priority: 'high'
                        });
                    } else if (hrvTrend > 0.1) {
                        insights.push({
                            title: 'üìà Improving Recovery Capacity',
                            message: `Your HRV has increased ${Math.round(hrvTrend * 10)}% this week! Your body is adapting well to training. This is an optimal time to maintain or slightly increase training intensity.`,
                            priority: 'positive'
                        });
                    }
                    
                    // Sleep Consistency Analysis
                    const sleepDurations = recentSleep.map(s => s.total_sleep_duration || 0);
                    const sleepVariability = calculateVariability(sleepDurations);
                    if (sleepVariability > 3600) { // More than 1 hour variation
                        insights.push({
                            title: '‚è∞ Inconsistent Sleep Schedule',
                            message: `Your sleep duration varies by ${Math.round(sleepVariability / 3600 * 10) / 10} hours between nights. Consistent sleep timing can improve recovery by up to 20%. Try setting a fixed bedtime alarm.`,
                            priority: 'medium'
                        });
                    }
                    
                    // Deep Sleep Analysis
                    const avgDeepSleep = recentSleep.reduce((sum, s) => sum + (s.deep_sleep_duration || 0), 0) / recentSleep.length;
                    const deepSleepPercentage = (avgDeepSleep / sleepDurations.reduce((a, b) => a + b, 0)) * sleepDurations.length * 100;
                    if (deepSleepPercentage < 13) {
                        insights.push({
                            title: 'üõèÔ∏è Low Deep Sleep',
                            message: `You're averaging only ${Math.round(deepSleepPercentage)}% deep sleep (target: 13-23%). Try avoiding screens 2 hours before bed, keeping your room cool (65-68¬∞F), and limiting alcohol intake.`,
                            priority: 'medium'
                        });
                    }
                }
            }

            // Advanced Training Load Analysis
            if (fitnessData.strava && fitnessData.strava.activities) {
                const activities = fitnessData.strava.activities;
                const lastWeek = activities.filter(a => new Date(a.start_date) >= new Date(Date.now() - 7 * 24 * 60 * 60 * 1000));
                const previousWeek = activities.filter(a => {
                    const date = new Date(a.start_date);
                    return date >= new Date(Date.now() - 14 * 24 * 60 * 60 * 1000) && 
                           date < new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                });
                
                // Acute:Chronic Workload Ratio
                const currentLoad = lastWeek.reduce((sum, a) => sum + (a.suffer_score || 0), 0);
                const previousLoad = previousWeek.reduce((sum, a) => sum + (a.suffer_score || 0), 0);
                const workloadRatio = previousLoad > 0 ? currentLoad / previousLoad : 0;
                
                if (workloadRatio > INSIGHT_THRESHOLDS.workloadRatioHigh) {
                    insights.push({
                        title: '‚ö†Ô∏è Rapid Training Load Increase',
                        message: `Your training load increased ${Math.round((workloadRatio - 1) * 100)}% this week. This aggressive increase elevates injury risk by 40%. Consider a recovery week or reducing volume by 20-30%.`,
                        priority: 'high'
                    });
                } else if (workloadRatio < INSIGHT_THRESHOLDS.workloadRatioLow && previousLoad > 100) {
                    insights.push({
                        title: 'Significant Load Reduction',
                        message: `Training load dropped ${Math.round((1 - workloadRatio) * 100)}%. While recovery is important, maintain at least 50% of your usual load to prevent detraining.`,
                        priority: 'medium'
                    });
                }
                
                // Training Monotony Analysis
                const dailyLoads = [];
                for (let i = 0; i < 7; i++) {
                    const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                    const dayLoad = lastWeek.filter(a => a.start_date.split('T')[0] === date)
                        .reduce((sum, a) => sum + (a.suffer_score || 0), 0);
                    dailyLoads.push(dayLoad);
                }
                
                const loadVariability = calculateVariability(dailyLoads);
                if (loadVariability < 20 && currentLoad > 200) {
                    insights.push({
                        title: 'üîÑ Monotonous Training Pattern',
                        message: `Your daily training loads are very similar. Varying intensity (easy/hard days) can improve adaptation and reduce burnout risk. Try the 80/20 principle: 80% easy, 20% hard.`,
                        priority: 'medium'
                    });
                }
            }
            
            // Cross-Platform Correlation Insights
            if (score !== null && components.recovery !== null && components.load !== null) {
                // Recovery-Load Mismatch Detection
                if (components.recovery < 60 && components.load < 50) {
                    insights.push({
                        title: 'üîç Recovery-Performance Mismatch',
                        message: `Low recovery (${Math.round(components.recovery)}) despite low training load suggests non-training stressors. Check work stress, nutrition, hydration, or potential illness.`,
                        priority: 'high'
                    });
                }
                
                // Optimization Windows
                if (components.recovery > 80 && components.hrv > 80 && components.sleep > 80) {
                    insights.push({
                        title: 'üöÄ Peak Performance Window',
                        message: `All recovery markers are excellent! This is an ideal time for high-intensity work, testing new PRs, or tackling challenging workouts. Your body is primed for adaptation.`,
                        priority: 'positive'
                    });
                }
                
                // Predictive Warnings
                if (components.rhr !== null && components.hrv !== null) {
                    const stressScore = (100 - components.rhr) + (100 - components.hrv);
                    if (stressScore > 80) {
                        insights.push({
                            title: 'üîÆ Early Fatigue Warning',
                            message: `Combined stress markers suggest fatigue is building before you feel it. Proactively reduce intensity over the next 2-3 days to prevent overreaching.`,
                            priority: 'medium'
                        });
                    }
                }
            }
            
            // Whoop-specific: Overreaching detection (high strain + declining recovery)
            if (Object.keys(daily.whoopStrain).length >= 3 && Object.keys(daily.whoopRecovery).length >= 3) {
                const days = Object.keys(daily.whoopStrain).sort();
                const last3 = days.slice(-3);
                const avgStrain3 = last3.reduce((s, d) => s + (daily.whoopStrain[d] || 0), 0) / last3.length;
                const recDays = Object.keys(daily.whoopRecovery).sort();
                const rec3 = recDays.slice(-3).map(d => daily.whoopRecovery[d]);
                const recTrend = calculateTrend(rec3);
                if (avgStrain3 >= INSIGHT_THRESHOLDS.overreachingAvgStrain || (avgStrain3 >= INSIGHT_THRESHOLDS.overreachingAvgWithDecline && recTrend < 0)) {
                    insights.push({
                        title: 'üî• Overreaching Risk Detected',
                        message: `High multi-day strain (avg ${avgStrain3.toFixed(1)}) with falling recovery. Plan a deload: cut volume 30‚Äì50% for 2‚Äì3 days and prioritize sleep.`,
                        priority: 'high'
                    });
                }
            }

            // Sleep debt via Whoop sleep performance
            if (Object.keys(daily.whoopSleepPerf).length >= 3) {
                const vals = Object.values(daily.whoopSleepPerf).slice(-3);
                const avgPerf3 = vals.reduce((a, b) => a + b, 0) / vals.length;
                if (avgPerf3 < INSIGHT_THRESHOLDS.sleepDebtPerfLow) {
                    insights.push({
                        title: 'üò¥ Sleep Debt Accumulating',
                        message: `Your Whoop sleep performance averaged ${Math.round(avgPerf3)}% over the last 3 nights. Aim for 95‚Äì105% to restore recovery capacity.`,
                        priority: 'medium'
                    });
                }
            }

            // Cross-device: Load up, Recovery down (last 3 vs previous 3 days)
            const stravaDates = Object.keys(daily.stravaLoad).sort();
            const recDates = Object.keys({ ...(daily.whoopRecovery || {}), ...(daily.ouraReadiness || {}) }).sort();
            if (stravaDates.length >= 6 && recDates.length >= 6) {
                const sPrev = stravaDates.slice(-6, -3).map(d => daily.stravaLoad[d] || 0);
                const sLast = stravaDates.slice(-3).map(d => daily.stravaLoad[d] || 0);
                const rPrev = recDates.slice(-6, -3).map(d => (daily.whoopRecovery[d] ?? daily.ouraReadiness[d] ?? 0));
                const rLast = recDates.slice(-3).map(d => (daily.whoopRecovery[d] ?? daily.ouraReadiness[d] ?? 0));
                const avg = arr => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
                const loadUp = avg(sPrev) > 0 ? (avg(sLast) - avg(sPrev)) / avg(sPrev) : 0;
                const recDown = avg(rPrev) > 0 ? (avg(rLast) - avg(rPrev)) / avg(rPrev) : 0;
                if (loadUp > INSIGHT_THRESHOLDS.loadUpPct && recDown < INSIGHT_THRESHOLDS.recDownPct) {
                    insights.push({
                        title: '‚öñÔ∏è Load ‚Üë while Recovery ‚Üì',
                        message: `Training load rose ${Math.round(loadUp * 100)}% while recovery fell ${Math.round(Math.abs(recDown) * 100)}%. Schedule a deload and prioritize sleep to avoid burnout.`,
                        priority: 'high'
                    });
                }
            }

            // Sleep Agreement (Whoop vs Oura)
            const overlapDays = Object.keys(daily.ouraSleepScore).filter(d => daily.whoopSleepPerf[d] !== undefined);
            if (overlapDays.length >= 3) {
                const absDiffs = overlapDays.map(d => Math.abs((daily.ouraSleepScore[d] || 0) - (daily.whoopSleepPerf[d] || 0)));
                const meanDiff = absDiffs.reduce((a, b) => a + b, 0) / absDiffs.length;
                const agreement = Math.max(0, 100 - meanDiff);
                const msgLow = agreement < INSIGHT_THRESHOLDS.sleepAgreementGood ? 'Devices disagree often; use trends over single-day scores.' : 'Devices largely agree; sleep assessments are consistent.';
                insights.push({
                    title: `üß™ Sleep Agreement: ${Math.round(agreement)}%`,
                    message: `Whoop vs Oura sleep scores differ by ~${Math.round(meanDiff)} points on average. ${msgLow}`,
                    priority: agreement < INSIGHT_THRESHOLDS.sleepAgreementGood ? 'medium' : 'positive'
                });
            }

            // Simple Training Readiness Recommendation
            const readiness = computeReadiness(components);
            insights.push({
                title: `üèÅ Today‚Äôs Readiness: ${readiness.type}`,
                message: readiness.message,
                priority: readiness.priority
            });

            // Summary when device sleep disagreement is high
            const sleepOverlapDays = Object.keys(daily.ouraSleepScore).filter(d => daily.whoopSleepPerf[d] !== undefined);
            if (sleepOverlapDays.length >= 3) {
                const absDiffs = sleepOverlapDays.map(d => Math.abs((daily.ouraSleepScore[d] || 0) - (daily.whoopSleepPerf[d] || 0)));
                const meanDiff = absDiffs.reduce((a, b) => a + b, 0) / absDiffs.length;
                const agreement = Math.max(0, 100 - meanDiff);
                if (agreement < INSIGHT_THRESHOLDS.sleepAgreementLow) {
                    insights.push({
                        title: 'üîç Devices Disagree on Sleep',
                        message: 'Your devices show low sleep agreement. Rely on multi-day trends and keep sleep hygiene consistent (timing, dark/cool room) while we learn your baseline.',
                        priority: 'medium'
                    });
                }
            }

            // Weekly Recommendations
            const dayOfWeek = new Date().getDay();
            if (score !== null) {
                if (dayOfWeek === 1 && score < 70) { // Monday
                    insights.push({
                        title: 'üìÖ Monday Recovery Protocol',
                        message: `Starting the week with a score of ${score}. Consider making this an active recovery day with light movement, stretching, or yoga to set up a strong training week.`,
                        priority: 'medium'
                    });
                } else if (dayOfWeek === 5 && components.strain > 70) { // Friday
                    insights.push({
                        title: 'üéØ Weekend Training Strategy',
                        message: `High training load heading into the weekend. If planning long sessions, ensure proper fueling and consider scheduling easier efforts for early next week.`,
                        priority: 'medium'
                    });
                }
            }

            // Sort insights by priority
            insights.sort((a, b) => {
                const priorityOrder = { high: 0, medium: 1, positive: 2 };
                return (priorityOrder[a.priority] || 3) - (priorityOrder[b.priority] || 3);
            });

            if (insights.length === 0) {
                insights.push({
                    title: 'Waiting for Data',
                    message: 'Connect more devices to unlock personalized insights about your training and recovery patterns.',
                    priority: 'low'
                });
            }

            const insightsContainer = document.getElementById('aiInsights');
            if (insightsContainer) {
                insightsContainer.innerHTML = insights.map(insight => `
                    <div class="insight-card ${insight.priority}">
                        <h4>${insight.title}</h4>
                        <p>${insight.message}</p>
                    </div>
                `).join('');
            }
        }
        
        // Helper functions for advanced analytics
        function calculateTrend(values) {
            if (values.length < 2) return 0;
            const n = values.length;
            const sumX = (n * (n - 1)) / 2;
            const sumY = values.reduce((a, b) => a + b, 0);
            const sumXY = values.reduce((sum, y, x) => sum + x * y, 0);
            const sumXX = (n * (n - 1) * (2 * n - 1)) / 6;
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const avgY = sumY / n;
            return avgY > 0 ? slope / avgY : 0; // Return relative change
        }
        
        function calculateVariability(values) {
            if (values.length < 2) return 0;
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
            const variance = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
            return Math.sqrt(variance);
        }

        // Garmin data fetching function (OAuth 2.0)
        async function fetchGarminData(tokenParam) {
            const button = document.querySelector('.btn-garmin');

            try {
                button.innerHTML = '<span class="loading-spinner"></span> Loading...';
                button.disabled = true;

                const token = tokenParam || localStorage.getItem('garmin_token');

                if (!token) {
                    throw new Error('No Garmin access token found');
                }

                // NOTE: Fetch data from database (received via PUSH webhooks)
                // This is compliant - we're NOT making PULL requests to Garmin API
                const userId = localStorage.getItem('userId');

                const [activitiesResponse, dailiesResponse] = await Promise.allSettled([
                    fetchWithRetry(`${API_CONFIG.backend}/api/garmin/db/activities?userId=${userId}`),
                    fetchWithRetry(`${API_CONFIG.backend}/api/garmin/db/dailies?userId=${userId}`)
                ]);

                fitnessData.garmin = {
                    dailySummary: dailiesResponse.status === 'fulfilled' && dailiesResponse.value.ok
                        ? await dailiesResponse.value.json()
                        : null,
                    activities: activitiesResponse.status === 'fulfilled' && activitiesResponse.value.ok
                        ? await activitiesResponse.value.json()
                        : null,
                    sleep: null,
                    connected: true,
                    pushOnly: true
                };

                button.innerHTML = '<span class="check-icon">‚úì</span> Connected';
                button.classList.add('connected');
                button.disabled = false;

                // Show disconnect button
                const disconnectBtn = document.querySelector('.btn-garmin-disconnect');
                if (disconnectBtn) {
                    disconnectBtn.style.display = 'block';
                }

                updateConnectionStatus();
                showMessage('Garmin connected! Data loaded from PUSH webhooks.', 'success');

            } catch (error) {
                console.error('Garmin data fetch error:', error);
                // Check if we have a token - if yes, still show connected
                const token = tokenParam || localStorage.getItem('garmin_token');
                if (token) {
                    fitnessData.garmin = {
                        dailySummary: null,
                        activities: null,
                        sleep: null,
                        connected: true
                    };

                    button.innerHTML = '<span class="check-icon">‚úì</span> Connected';
                    button.classList.add('connected');
                    button.disabled = false;

                    // Show disconnect button
                    const disconnectBtn = document.querySelector('.btn-garmin-disconnect');
                    if (disconnectBtn) {
                        disconnectBtn.style.display = 'block';
                    }

                    showMessage('Garmin connected! Data will sync automatically.', 'success');
                } else {
                    showMessage(`Failed to connect Garmin: ${error.message}`, 'error');
                    button.innerHTML = 'Connect Garmin';
                    button.disabled = false;
                }
            }
        }

        // Whoop token refresh function
        async function refreshWhoopToken(refreshToken) {
            console.log('üîÑ Refreshing Whoop token...');

            try {
                const response = await fetch(`${API_CONFIG.backend}/api/whoop/refresh`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        refresh_token: refreshToken
                    })
                });

                if (!response.ok) {
                    throw new Error('Token refresh failed');
                }

                const data = await response.json();

                // Store new tokens
                localStorage.setItem('whoop_token', data.access_token);
                if (data.refresh_token) {
                    localStorage.setItem('whoop_refresh_token', data.refresh_token);
                }
                if (data.expires_in) {
                    const expiryTime = Date.now() + (data.expires_in * 1000);
                    localStorage.setItem('whoop_expiry', expiryTime);
                }

                console.log('‚úÖ Whoop token refreshed successfully');

                // Fetch data with new token
                fetchWhoopData(data.access_token);

            } catch (error) {
                console.error('‚ùå Failed to refresh Whoop token:', error);
                showMessage('Whoop connection expired. Please reconnect.', 'warning');
                localStorage.removeItem('whoop_token');
                localStorage.removeItem('whoop_expiry');
                localStorage.removeItem('whoop_refresh_token');
            }
        }

        // Whoop data fetching function
        async function fetchWhoopData(tokenParam) {
            console.log('üîÑ fetchWhoopData called with token:', tokenParam ? 'provided' : 'using stored');
            const button = document.querySelector('.btn-whoop');

            try {
                button.innerHTML = '<span class="loading-spinner"></span> Loading...';
                button.disabled = true;

                const token = tokenParam || localStorage.getItem('whoop_token');
                console.log('üîë Using token:', token ? token.substring(0, 20) + '...' : 'none');

                if (!token) {
                    throw new Error('No Whoop access token found');
                }

                const today = new Date();
                const startDate = new Date(today.getTime() - 14 * 24 * 60 * 60 * 1000).toISOString();
                const endDate = today.toISOString();

                console.log('üì° Fetching Whoop data from backend...');
                console.log('Date range:', startDate, 'to', endDate);

                // Fetch Whoop data endpoints through backend
                const [profileResponse, recoveryResponse, workoutResponse, sleepResponse, cyclesResponse] = await Promise.allSettled([
                    fetchWithRetry(`${API_CONFIG.backend}/api/whoop/profile?token=${token}`).catch(e => ({ ok: false, error: e })),
                    fetchWithRetry(`${API_CONFIG.backend}/api/whoop/recovery?token=${token}&start=${startDate}&end=${endDate}`).catch(e => ({ ok: false, error: e })),
                    fetchWithRetry(`${API_CONFIG.backend}/api/whoop/workouts?token=${token}&start=${startDate}&end=${endDate}`).catch(e => ({ ok: false, error: e })),
                    fetchWithRetry(`${API_CONFIG.backend}/api/whoop/sleep?token=${token}&start=${startDate}&end=${endDate}`).catch(e => ({ ok: false, error: e })),
                    fetchWithRetry(`${API_CONFIG.backend}/api/whoop/cycles?token=${token}&start=${startDate}&end=${endDate}`).catch(e => ({ ok: false, error: e }))
                ]);

                console.log('Backend responses:', {
                    profile: profileResponse.status,
                    recovery: recoveryResponse.status,
                    workout: workoutResponse.status,
                    sleep: sleepResponse.status,
                    cycles: cyclesResponse.status
                });

                let profile = null, recovery = null, workouts = null, sleep = null, cycles = null;
                let hasAnyData = false;

                // Process responses with validation
                if (profileResponse.status === 'fulfilled' && profileResponse.value.ok) {
                    const data = await profileResponse.value.json();
                    if (data) {
                        profile = data;
                        hasAnyData = true;
                    }
                }

                if (recoveryResponse.status === 'fulfilled' && recoveryResponse.value.ok) {
                    const data = await recoveryResponse.value.json();
                    if (data && data.records && Array.isArray(data.records)) {
                        recovery = data.records;
                        hasAnyData = true;
                    }
                }

                if (workoutResponse.status === 'fulfilled' && workoutResponse.value.ok) {
                    const data = await workoutResponse.value.json();
                    if (data && data.records && Array.isArray(data.records)) {
                        workouts = data.records;
                        hasAnyData = true;
                    }
                }

                if (sleepResponse.status === 'fulfilled' && sleepResponse.value.ok) {
                    const data = await sleepResponse.value.json();
                    if (data && data.records && Array.isArray(data.records)) {
                        sleep = data.records;
                        hasAnyData = true;
                    }
                }

                if (cyclesResponse.status === 'fulfilled' && cyclesResponse.value.ok) {
                    const data = await cyclesResponse.value.json();
                    if (data && data.records && Array.isArray(data.records)) {
                        cycles = data.records;
                        hasAnyData = true;
                    }
                }

                if (hasAnyData) {
                    fitnessData.whoop = {
                        profile,
                        recovery,
                        workouts,
                        sleep,
                        cycles,
                        connected: true
                    };

                    fitnessData.lastUpdated = new Date();
                    updateConnectionStatus();
                    showMessage('Whoop data loaded successfully!', 'success');

                    // Update UI with Whoop data
                    if (document.getElementById('whoop').classList.contains('active')) {
                        updateWhoopDisplay();
                    }

                    const userName = profile?.first_name || 'Whoop User';
                    button.innerHTML = `<span class="check-icon">‚úì</span> ${userName} - Connected`;
                    button.classList.add('connected');

                    // Show disconnect button
                    const disconnectBtn = document.querySelector('.btn-whoop-disconnect');
                    if (disconnectBtn) {
                        disconnectBtn.style.display = 'block';
                    }
                } else {
                    throw new Error('No data available from Whoop');
                }

            } catch (error) {
                console.error('Whoop data fetch error:', error);
                showMessage(`Failed to load Whoop data: ${error.message}`, 'error');
                button.innerHTML = 'Connect Whoop';
                button.disabled = false;
            }
        }

        // Update Whoop display
        function updateWhoopDisplay() {
            if (!fitnessData.whoop) return;

            const { profile, recovery, workouts, sleep, cycles } = fitnessData.whoop;

            console.log('üé® Updating Whoop display with data:', {
                profile: !!profile,
                recovery: recovery?.length,
                workouts: workouts?.length,
                sleep: sleep?.length,
                cycles: cycles?.length
            });

            // Update Whoop-specific UI elements
            const updateStat = (id, value, unit = '') => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value !== null && value !== undefined ? `${value}${unit}` : '--';
                }
            };

            // Update recovery data
            if (recovery && recovery.length > 0) {
                const latestRecovery = recovery[recovery.length - 1];
                console.log('Latest recovery data:', latestRecovery);

                const recoveryScore = latestRecovery.score?.recovery_score;
                if (recoveryScore !== undefined) {
                    console.log('üîç Raw recovery score:', recoveryScore);
                    // If value is > 1, it's already a percentage (36.0), if < 1, it's decimal (0.36)
                    const displayValue = recoveryScore > 1 ? Math.round(recoveryScore) : Math.round(recoveryScore * 100);
                    updateStat('whoopRecovery', displayValue, '%');
                }

                updateStat('whoopHRV', Math.round(latestRecovery.score?.hrv_rmssd_milli), '');
            }

            // Update sleep data
            if (sleep && sleep.length > 0) {
                const latestSleep = sleep[sleep.length - 1];
                console.log('üò¥ Latest sleep data:', latestSleep);

                const sleepPerformance = latestSleep.score?.sleep_performance_percentage;
                if (sleepPerformance !== undefined) {
                    console.log('üîç Raw sleep performance:', sleepPerformance);
                    // If value is > 1, it's already a percentage (46.0), if < 1, it's decimal (0.46)
                    const displayValue = sleepPerformance > 1 ? Math.round(sleepPerformance) : Math.round(sleepPerformance * 100);
                    updateStat('whoopSleep', displayValue, '%');
                }
            }

            // Update strain from cycles data (and extract recovery/sleep if not already set)
            if (cycles && cycles.length > 0) {
                const latestCycle = cycles[cycles.length - 1];
                console.log('üî• Latest cycle data:', latestCycle);

                updateStat('whoopStrain', latestCycle.score?.strain?.toFixed(1), '');

                // If recovery endpoint failed, try to get recovery from cycle
                if (!recovery || recovery.length === 0) {
                    const recoveryScore = latestCycle.score?.recovery_score;
                    if (recoveryScore !== undefined) {
                        const displayValue = recoveryScore > 1 ? Math.round(recoveryScore) : Math.round(recoveryScore * 100);
                        updateStat('whoopRecovery', displayValue, '%');
                    }

                    const hrv = latestCycle.score?.hrv_rmssd_milli;
                    if (hrv !== undefined) {
                        updateStat('whoopHRV', Math.round(hrv), '');
                    }
                }

                // If sleep endpoint failed, try to get sleep from cycle
                if (!sleep || sleep.length === 0) {
                    const sleepPerformance = latestCycle.score?.sleep_performance_percentage;
                    if (sleepPerformance !== undefined) {
                        const displayValue = sleepPerformance > 1 ? Math.round(sleepPerformance) : Math.round(sleepPerformance * 100);
                        updateStat('whoopSleep', displayValue, '%');
                    }
                }
            }

            // Update activities list
            if (workouts && workouts.length > 0) {
                const activitiesList = document.getElementById('whoopActivitiesList');
                if (activitiesList) {
                    activitiesList.innerHTML = workouts.slice(0, 5).map(workout => `
                        <div style="padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between;">
                            <span>${workout.sport_name || 'Activity'}</span>
                            <span>Strain: ${workout.score?.strain?.toFixed(1) || 'N/A'}</span>
                        </div>
                    `).join('');
                }
            }

            // Update Whoop trend chart
            updateWhoopTrendChart();
            updateWhoopRecoveryTrendChart();
            updateWhoopStrainTarget();

            console.log('‚úÖ Whoop display updated successfully');
        }

        // Update Whoop Trend Chart with Sleep & Recovery data
        function updateWhoopTrendChart() {
            if (!charts.whoopTrend || !fitnessData.whoop) return;

            const { recovery, sleep } = fitnessData.whoop;

            // Get last 7 days of data for the trend
            const last7Days = [];
            const today = new Date();
            for (let i = 6; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                last7Days.push(date);
            }

            // Prepare recovery data for the last 7 days
            const recoveryData = last7Days.map(date => {
                const dateStr = date.toISOString().split('T')[0];
                const dayRecovery = recovery?.find(r => {
                    const recordDate = new Date(r.created_at || r.date).toISOString().split('T')[0];
                    return recordDate === dateStr;
                });

                if (dayRecovery?.score?.recovery_score) {
                    const value = dayRecovery.score.recovery_score;
                    return value > 1 ? value : value * 100; // Handle both formats
                }
                return null;
            });

            // Prepare sleep data for the last 7 days
            const sleepData = last7Days.map(date => {
                const dateStr = date.toISOString().split('T')[0];
                const daySleep = sleep?.find(s => {
                    const recordDate = new Date(s.created_at || s.start).toISOString().split('T')[0];
                    return recordDate === dateStr;
                });

                if (daySleep?.score?.sleep_performance_percentage) {
                    const value = daySleep.score.sleep_performance_percentage;
                    return value > 1 ? value : value * 100; // Handle both formats
                }
                return null;
            });

            const labels = last7Days.map(date =>
                date.toLocaleDateString('en-US', { weekday: 'short' })
            );

            charts.whoopTrend.data = {
                labels: labels,
                datasets: [
                    {
                        label: 'Recovery %',
                        data: recoveryData,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.4,
                        fill: false,
                        pointBackgroundColor: '#10b981',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 4
                    },
                    {
                        label: 'Sleep Performance %',
                        data: sleepData,
                        borderColor: '#8b5cf6',
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        tension: 0.4,
                        fill: false,
                        pointBackgroundColor: '#8b5cf6',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 4
                    }
                ]
            };

            charts.whoopTrend.update();

            console.log('üìà Whoop trend chart updated:', {
                recoveryPoints: recoveryData.filter(v => v !== null).length,
                sleepPoints: sleepData.filter(v => v !== null).length
            });
        }

        function updateWhoopRecoveryTrendChart() {
            if (!charts.whoopRecoveryTrend || !fitnessData.whoop || !fitnessData.whoop.recovery) return;
            const days = getInsightWindowDays();
            const today = new Date();
            const labels = [];
            const keys = [];
            for (let i=days-1;i>=0;i--){ const d=new Date(today); d.setDate(d.getDate()-i); labels.push(d.toLocaleDateString('en-US',{weekday:'short'})); keys.push(d.toISOString().split('T')[0]); }
            const recMap = {};
            for (const r of fitnessData.whoop.recovery) {
                const k = new Date(r.created_at || r.date).toISOString().split('T')[0];
                const val = r.score?.recovery_score;
                if (val !== undefined) recMap[k] = val > 1 ? val : val * 100;
            }
            const rec = keys.map(k => recMap[k] ?? null);
            const valid = rec.filter(v => v !== null);
            const baseline = valid.length ? Math.round(valid.reduce((a,b)=>a+b,0)/valid.length) : null;
            charts.whoopRecoveryTrend.data = {
                labels,
                datasets: [
                    { label: 'Recovery %', data: rec, borderColor: '#10b981', backgroundColor: 'rgba(16,185,129,0.2)', tension: 0.3 },
                    { label: 'Baseline', data: rec.map(_=> baseline), borderColor: '#6b7280', borderDash: [6,6], pointRadius: 0 }
                ]
            };
            charts.whoopRecoveryTrend.update();
        }

        function updateWhoopStrainTarget() {
            const el = document.getElementById('whoopStrainTargetText');
            if (!el || !fitnessData.whoop || !fitnessData.whoop.recovery) return;
            const latest = fitnessData.whoop.recovery[fitnessData.whoop.recovery.length - 1];
            if (!latest) { el.textContent = '‚Äî'; return; }
            const raw = latest.score?.recovery_score;
            if (raw === undefined) { el.textContent = '‚Äî'; return; }
            const rec = raw > 1 ? raw : raw * 100;
            let zone = 'Yellow', target = '10‚Äì12';
            if (rec >= 67) { zone = 'Green'; target = '12‚Äì15'; }
            else if (rec < 34) { zone = 'Red'; target = '8‚Äì10'; }
            el.textContent = `Recovery ${Math.round(rec)}% (${zone}). Suggested strain target: ${target}. Adjust for your goals and feel.`;
        }

        // Update Garmin display
        async function updateGarminDisplay() {
            console.log('üî• UPDATE GARMIN DISPLAY CALLED');
            try {
                const userId = localStorage.getItem('userId');
                console.log('üî• userId:', userId);
                if (!userId) {
                    console.log('‚ùå No userId - returning');
                    return;
                }

                // Check if user has Garmin connected (using correct key name)
                const garminToken = localStorage.getItem('garmin_token');
                console.log('üî• garminToken exists:', !!garminToken);
                if (!garminToken) {
                    console.log('‚ùå No Garmin token - showing connect message');
                    document.getElementById('garminActivitiesList').innerHTML =
                        '<div style="text-align: center; padding: 20px; color: #6b7280;">Connect Garmin to see your health data</div>';
                    return;
                }

                // Fetch real data from database (received via PUSH webhooks)
                console.log('Fetching Garmin data from database for user:', userId);
                console.log('API URL:', `${API_CONFIG.backend}/api/garmin/db/activities?userId=${userId}`);

                const [activitiesResponse, dailiesResponse] = await Promise.allSettled([
                    fetch(`${API_CONFIG.backend}/api/garmin/db/activities?userId=${userId}`),
                    fetch(`${API_CONFIG.backend}/api/garmin/db/dailies?userId=${userId}`)
                ]);

                let activities = [];
                let dailySummaries = [];

                console.log('üî• activitiesResponse:', activitiesResponse);
                if (activitiesResponse.status === 'fulfilled' && activitiesResponse.value.ok) {
                    const data = await activitiesResponse.value.json();
                    activities = data.activities || [];
                    console.log('‚úÖ Loaded', activities.length, 'Garmin activities', activities);
                } else {
                    console.log('‚ùå Activities fetch failed:', activitiesResponse);
                }

                console.log('üî• dailiesResponse:', dailiesResponse);
                if (dailiesResponse.status === 'fulfilled' && dailiesResponse.value.ok) {
                    const data = await dailiesResponse.value.json();
                    dailySummaries = data.dailies || [];
                    console.log('‚úÖ Loaded', dailySummaries.length, 'daily summaries');
                } else {
                    console.log('‚ùå Dailies fetch failed:', dailiesResponse);
                }

                // Update hero stat cards
                console.log('üî• Setting garminActivities to:', activities.length);
                document.getElementById('garminActivities').textContent = activities.length;

                const totalDistance = activities.reduce((sum, a) => sum + (a.distanceInMeters || 0), 0);
                document.getElementById('garminDistance').textContent = (totalDistance / 1000).toFixed(1) + ' km';

                const avgHr = activities.length > 0
                    ? Math.round(activities.reduce((sum, a) => sum + (a.averageHeartRateInBeatsPerMinute || 0), 0) / activities.length)
                    : '--';
                document.getElementById('garminAvgHR').textContent = avgHr === '--' ? avgHr : avgHr + ' bpm';

                const totalTime = activities.reduce((sum, a) => sum + (a.durationInSeconds || 0), 0);
                const hours = Math.floor(totalTime / 3600);
                const minutes = Math.floor((totalTime % 3600) / 60);
                document.getElementById('garminTrainingTime').textContent = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;

                // Update new health metrics from daily summaries
                if (dailySummaries.length > 0) {
                    const latest = dailySummaries[0];

                    // Body Battery
                    if (latest.bodyBatteryHighestValue) {
                        document.getElementById('garminBodyBattery').textContent = latest.bodyBatteryHighestValue;
                    }

                    // Stress Level
                    if (latest.averageStressLevel) {
                        document.getElementById('garminStressLevel').textContent = latest.averageStressLevel;
                    }

                    // HRV
                    if (latest.hrvAvg) {
                        document.getElementById('garminHRV').textContent = Math.round(latest.hrvAvg);
                    }

                    // Respiration
                    if (latest.avgWakingRespirationValue) {
                        document.getElementById('garminRespiration').textContent = latest.avgWakingRespirationValue.toFixed(1);
                    }
                }

                // Update activities list with real activities
                const activitiesList = document.getElementById('garminActivitiesList');
                if (activities.length === 0) {
                    activitiesList.innerHTML = '<div style="text-align: center; padding: 20px; color: #9ca3af;">No activities yet. Record a workout on your Garmin device!</div>';
                } else {
                    activitiesList.innerHTML = activities.map(activity => `
                    <div style="padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.02);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <strong style="font-size: 1.1rem;">${activity.activityName || activity.activityType}</strong>
                                <div style="font-size: 0.9rem; color: #9ca3af; margin-top: 2px;">${new Date(activity.startTimeInSeconds * 1000).toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}</div>
                            </div>
                            <div style="text-align: right;">
                                <span style="background: #667eea; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">
                                    ${activity.activityType}
                                </span>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; font-size: 0.9rem;">
                            <div>
                                <span style="color: #9ca3af;">Duration:</span>
                                <strong style="color: #ffffff; margin-left: 5px;">${Math.floor(activity.durationInSeconds / 60)}min</strong>
                            </div>
                            ${activity.distanceInMeters ? `<div>
                                <span style="color: #9ca3af;">Distance:</span>
                                <strong style="color: #ffffff; margin-left: 5px;">${(activity.distanceInMeters / 1000).toFixed(2)} km</strong>
                            </div>` : ''}
                            ${activity.averageHeartRateInBeatsPerMinute ? `<div>
                                <span style="color: #9ca3af;">Avg HR:</span>
                                <strong style="color: #ffffff; margin-left: 5px;">${activity.averageHeartRateInBeatsPerMinute} bpm</strong>
                            </div>` : ''}
                            ${activity.maxHeartRateInBeatsPerMinute ? `<div>
                                <span style="color: #9ca3af;">Max HR:</span>
                                <strong style="color: #ffffff; margin-left: 5px;">${activity.maxHeartRateInBeatsPerMinute} bpm</strong>
                            </div>` : ''}
                            ${activity.activeKilocalories ? `<div>
                                <span style="color: #9ca3af;">Calories:</span>
                                <strong style="color: #ffffff; margin-left: 5px;">${activity.activeKilocalories} kcal</strong>
                            </div>` : ''}
                            ${activity.deviceModel ? `<div>
                                <span style="color: #9ca3af;">Device:</span>
                                <strong style="color: #ffffff; margin-left: 5px;">Garmin ${activity.deviceModel}</strong>
                            </div>` : `<div>
                                <span style="color: #9ca3af;">Device:</span>
                                <strong style="color: #ffffff; margin-left: 5px;">Garmin</strong>
                            </div>`}
                        </div>
                    </div>
                `).join('');
                }

                // Create Heart Rate Zones TIME IN ZONE chart from activity data
                const zonesCtx = document.getElementById('garminZonesChart');
                if (zonesCtx && activities.length > 0) {
                    // Calculate time in each zone (estimated based on avg HR and duration)
                    const maxHRValue = Math.max(...activities.map(a => a.maxHeartRateInBeatsPerMinute || 0));

                    // Define zone boundaries (% of max HR)
                    const zones = {
                        recovery: { min: 0.5, max: 0.6, time: 0 },
                        fatBurn: { min: 0.6, max: 0.7, time: 0 },
                        cardio: { min: 0.7, max: 0.8, time: 0 },
                        threshold: { min: 0.8, max: 0.9, time: 0 },
                        peak: { min: 0.9, max: 1.0, time: 0 }
                    };

                    // Estimate time in each zone based on average HR
                    activities.forEach(activity => {
                        if (activity.averageHeartRateInBeatsPerMinute && activity.durationInSeconds) {
                            const avgHRPercent = activity.averageHeartRateInBeatsPerMinute / maxHRValue;
                            const durationMinutes = activity.durationInSeconds / 60;

                            // Find which zone the average HR falls into
                            if (avgHRPercent >= zones.recovery.min && avgHRPercent < zones.recovery.max) {
                                zones.recovery.time += durationMinutes;
                            } else if (avgHRPercent >= zones.fatBurn.min && avgHRPercent < zones.fatBurn.max) {
                                zones.fatBurn.time += durationMinutes;
                            } else if (avgHRPercent >= zones.cardio.min && avgHRPercent < zones.cardio.max) {
                                zones.cardio.time += durationMinutes;
                            } else if (avgHRPercent >= zones.threshold.min && avgHRPercent < zones.threshold.max) {
                                zones.threshold.time += durationMinutes;
                            } else if (avgHRPercent >= zones.peak.min) {
                                zones.peak.time += durationMinutes;
                            }
                        }
                    });

                    // Destroy existing chart if it exists
                    const existingChart = Chart.getChart(zonesCtx);
                    if (existingChart) existingChart.destroy();

                    new Chart(zonesCtx.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: ['Recovery\n(50-60%)', 'Fat Burn\n(60-70%)', 'Cardio\n(70-80%)', 'Threshold\n(80-90%)', 'Peak\n(90-100%)'],
                            datasets: [{
                                label: 'Time (minutes)',
                                data: [
                                    Math.round(zones.recovery.time),
                                    Math.round(zones.fatBurn.time),
                                    Math.round(zones.cardio.time),
                                    Math.round(zones.threshold.time),
                                    Math.round(zones.peak.time)
                                ],
                                backgroundColor: ['#4CAF50', '#8BC34A', '#FFC107', '#FF9800', '#F44336']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return context.parsed.y + ' minutes';
                                        }
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: { display: true, text: 'Time (minutes)' }
                                }
                            }
                        }
                    });
                } else if (zonesCtx) {
                    // Show placeholder
                    zonesCtx.getContext('2d').clearRect(0, 0, zonesCtx.width, zonesCtx.height);
                }

                // Body Battery, Stress, HRV charts will show once daily summaries arrive via PUSH
                console.log('Charts ready - waiting for daily summary data from PUSH notifications');

            } catch (error) {
                console.error('‚ùå Error updating Garmin display:', error);
                console.error('Error stack:', error.stack);
            }
        }

        function updateConnectionStatus() {
            const connections = ['strava', 'oura', 'whoop', 'garmin'];
            const container = document.getElementById('overviewConnections');
            
            if (container) {
                container.innerHTML = connections.map(service => {
                    const isConnected = fitnessData[service] !== null;
                    let logoHtml = '';

                    if (service === 'garmin') {
                        logoHtml = '<img src="/src/images/Garmin.svg" alt="Garmin" style="height: 28px; width: auto; vertical-align: middle; margin-right: 8px;">';
                    } else if (service === 'strava') {
                        logoHtml = '<img src="/src/images/strava.svg" alt="Strava" style="height: 20px; width: auto; vertical-align: middle; margin-right: 8px;">';
                    } else if (service === 'whoop') {
                        logoHtml = '<img src="/src/images/WHOOP.svg" alt="Whoop" style="height: 20px; width: auto; vertical-align: middle; margin-right: 8px;">';
                    } else if (service === 'oura') {
                        logoHtml = '<img src="/src/images/oura.png" alt="Oura" style="height: 20px; width: auto; vertical-align: middle; margin-right: 8px;">';
                    }

                    return `
                        <div class="connection-badge ${isConnected ? 'connected' : 'disconnected'}">
                            ${logoHtml} ${isConnected ? '‚úÖ' : '‚ùå'}
                        </div>
                    `;
                }).join('');
            }
        }

        // ===== RUNNING ANALYTICS =====
        function updateRunningAnalytics() {
            if (!fitnessData.strava || !fitnessData.strava.activities) {
                showEmptyRunningState();
                return;
            }

            const runActivities = fitnessData.strava.activities.filter(a => 
                a.type === 'Run' || a.sport_type === 'Run'
            );

            if (runActivities.length === 0) {
                showEmptyRunningState();
                return;
            }

            // Calculate date ranges
            const now = new Date();
            const fourWeeksAgo = new Date(now.getTime() - 28 * 24 * 60 * 60 * 1000);
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            const eightWeeksAgo = new Date(now.getTime() - 56 * 24 * 60 * 60 * 1000);

            // Filter runs by time periods
            const recentRuns = runActivities.filter(a => new Date(a.start_date) >= fourWeeksAgo);
            const lastWeekRuns = runActivities.filter(a => new Date(a.start_date) >= oneWeekAgo);
            const previousPeriodRuns = runActivities.filter(a => {
                const date = new Date(a.start_date);
                return date >= eightWeeksAgo && date < fourWeeksAgo;
            });

            // Update running volume cards
            updateRunningVolumeCards(recentRuns, previousPeriodRuns);
            
            // Update training load chart
            updateRunningLoadChart(recentRuns);
            
            // Update pace and HR trends
            updateRunningPaceChart(recentRuns);
            
            // Update intensity distribution
            updateRunningIntensityDistribution(recentRuns);
            
            // Update progress table
            updateRunningProgressTable(recentRuns, previousPeriodRuns);
            
            // Update personal records
            updateRunningRecords(runActivities);
            
            // Update endurance chart
            updateRunningEnduranceChart(recentRuns);
            
            // Generate running-specific insights
            generateRunningInsights(recentRuns, previousPeriodRuns);
        }

        function updateRunningVolumeCards(recentRuns, previousRuns) {
            // Total distance
            const totalDistance = recentRuns.reduce((sum, r) => sum + (r.distance || 0), 0) / 1000;
            const previousDistance = previousRuns.reduce((sum, r) => sum + (r.distance || 0), 0) / 1000;
            document.getElementById('runningDistance').textContent = `${Math.round(totalDistance)}km`;
            updateTrendArrow('runningDistanceTrend', totalDistance, previousDistance);

            // Weekly frequency
            const weeklyFrequency = recentRuns.length / 4;
            const previousFrequency = previousRuns.length / 4;
            document.getElementById('runningFrequency').textContent = weeklyFrequency.toFixed(1);
            updateTrendArrow('runningFrequencyTrend', weeklyFrequency, previousFrequency);

            // Average duration
            const avgDuration = recentRuns.length > 0 ? 
                recentRuns.reduce((sum, r) => sum + (r.moving_time || 0), 0) / recentRuns.length / 60 : 0;
            const previousAvgDuration = previousRuns.length > 0 ?
                previousRuns.reduce((sum, r) => sum + (r.moving_time || 0), 0) / previousRuns.length / 60 : 0;
            document.getElementById('runningDuration').textContent = formatDuration(avgDuration);
            updateTrendArrow('runningDurationTrend', avgDuration, previousAvgDuration);

            // Total elevation
            const totalElevation = recentRuns.reduce((sum, r) => sum + (r.total_elevation_gain || 0), 0);
            const previousElevation = previousRuns.reduce((sum, r) => sum + (r.total_elevation_gain || 0), 0);
            document.getElementById('runningElevation').textContent = `${Math.round(totalElevation)}m`;
            updateTrendArrow('runningElevationTrend', totalElevation, previousElevation);
        }

        function updateTrendArrow(elementId, current, previous) {
            const element = document.getElementById(elementId);
            if (!element) return;

            const change = previous > 0 ? ((current - previous) / previous) * 100 : 0;
            
            if (Math.abs(change) < 5) {
                element.textContent = '‚Üí';
                element.className = 'trend-arrow neutral';
            } else if (change > 0) {
                element.textContent = '‚Üë';
                element.className = 'trend-arrow up';
            } else {
                element.textContent = '‚Üì';
                element.className = 'trend-arrow down';
            }
        }

        function updateRunningLoadChart(runs) {
            if (!charts.runningLoad) {
                charts.runningLoad = new Chart(document.getElementById('runningLoadChart'), {
                    type: 'bar',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: true }
                        },
                        scales: {
                            y: { beginAtZero: true }
                        }
                    }
                });
            }

            // Sort runs by date
            const sortedRuns = runs.sort((a, b) => new Date(a.start_date) - new Date(b.start_date));
            
            const labels = sortedRuns.map(r => new Date(r.start_date).toLocaleDateString());
            const sufferScores = sortedRuns.map(r => r.suffer_score || 0);
            const avgHR = sortedRuns.map(r => r.average_heartrate || 0);

            charts.runningLoad.data = {
                labels: labels,
                datasets: [
                    {
                        label: 'Training Load',
                        data: sufferScores,
                        backgroundColor: '#FC4C02',
                        yAxisID: 'y'
                    },
                    {
                        label: 'Avg HR',
                        data: avgHR,
                        type: 'line',
                        borderColor: '#dc2626',
                        backgroundColor: 'transparent',
                        yAxisID: 'y1'
                    }
                ]
            };

            charts.runningLoad.options.scales = {
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: { display: true, text: 'Suffer Score' }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: { display: true, text: 'Heart Rate (bpm)' },
                    grid: { drawOnChartArea: false }
                }
            };

            charts.runningLoad.update();
        }

        function updateRunningPaceChart(runs) {
            if (!charts.runningPace) {
                charts.runningPace = new Chart(document.getElementById('runningPaceChart'), {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: true }
                        },
                        scales: {
                            y: {
                                reverse: true,
                                ticks: {
                                    callback: function(value) {
                                        const minutes = Math.floor(value);
                                        const seconds = Math.round((value - minutes) * 60);
                                        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // Group runs by week
            const weeklyData = {};
            runs.forEach(run => {
                const weekStart = getWeekStart(new Date(run.start_date));
                const weekKey = weekStart.toISOString().split('T')[0];
                
                if (!weeklyData[weekKey]) {
                    weeklyData[weekKey] = {
                        paces: [],
                        heartRates: [],
                        distances: []
                    };
                }
                
                const paceMinPerKm = run.distance > 0 ? (run.moving_time / 60) / (run.distance / 1000) : 0;
                if (paceMinPerKm > 0 && paceMinPerKm < 10) { // Filter out unrealistic paces
                    weeklyData[weekKey].paces.push(paceMinPerKm);
                    weeklyData[weekKey].heartRates.push(run.average_heartrate || 0);
                    weeklyData[weekKey].distances.push(run.distance);
                }
            });

            const weeks = Object.keys(weeklyData).sort();
            const avgPaces = weeks.map(week => {
                const data = weeklyData[week];
                return data.paces.length > 0 ? 
                    data.paces.reduce((a, b) => a + b) / data.paces.length : null;
            });

            const bestPaces = weeks.map(week => {
                const data = weeklyData[week];
                return data.paces.length > 0 ? Math.min(...data.paces) : null;
            });

            const avgHeartRates = weeks.map(week => {
                const data = weeklyData[week];
                const validHRs = data.heartRates.filter(hr => hr > 0);
                return validHRs.length > 0 ? 
                    validHRs.reduce((a, b) => a + b) / validHRs.length : null;
            });

            charts.runningPace.data = {
                labels: weeks.map(w => new Date(w).toLocaleDateString()),
                datasets: [
                    {
                        label: 'Best Pace',
                        data: bestPaces,
                        borderColor: '#10b981',
                        backgroundColor: 'transparent',
                        tension: 0.4
                    },
                    {
                        label: 'Avg Pace',
                        data: avgPaces,
                        borderColor: '#667eea',
                        backgroundColor: 'transparent',
                        tension: 0.4
                    }
                ]
            };

            charts.runningPace.update();
        }

        function updateRunningIntensityDistribution(runs) {
            if (!charts.runningIntensity) {
                charts.runningIntensity = new Chart(document.getElementById('runningIntensityChart'), {
                    type: 'doughnut',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
            }

            // Categorize runs by intensity based on suffer score per minute
            let easy = 0, moderate = 0, hard = 0;
            
            runs.forEach(run => {
                const sufferPerMin = run.suffer_score / (run.moving_time / 60);
                if (sufferPerMin < 0.5) easy++;
                else if (sufferPerMin < 1.0) moderate++;
                else hard++;
            });

            charts.runningIntensity.data = {
                labels: ['Easy', 'Moderate', 'Hard'],
                datasets: [{
                    data: [easy, moderate, hard],
                    backgroundColor: ['#10b981', '#f59e0b', '#dc2626']
                }]
            };

            charts.runningIntensity.update();
        }

        function updateRunningProgressTable(recentRuns, previousRuns) {
            const tbody = document.getElementById('runningProgressBody');
            if (!tbody) return;

            // Calculate metrics
            const currentMetrics = calculateRunMetrics(recentRuns);
            const previousMetrics = calculateRunMetrics(previousRuns);

            const rows = [
                {
                    metric: 'Avg Distance/Run',
                    previous: `${previousMetrics.avgDistance.toFixed(1)}km`,
                    current: `${currentMetrics.avgDistance.toFixed(1)}km`,
                    change: calculateChange(currentMetrics.avgDistance, previousMetrics.avgDistance)
                },
                {
                    metric: 'Weekly Runs',
                    previous: previousMetrics.weeklyRuns.toFixed(1),
                    current: currentMetrics.weeklyRuns.toFixed(1),
                    change: calculateChange(currentMetrics.weeklyRuns, previousMetrics.weeklyRuns)
                },
                {
                    metric: 'Avg Pace',
                    previous: formatPace(previousMetrics.avgPace),
                    current: formatPace(currentMetrics.avgPace),
                    change: calculateChange(previousMetrics.avgPace, currentMetrics.avgPace, true) // Reverse for pace
                },
                {
                    metric: 'Longest Run',
                    previous: `${previousMetrics.longestRun.toFixed(1)}km`,
                    current: `${currentMetrics.longestRun.toFixed(1)}km`,
                    change: calculateChange(currentMetrics.longestRun, previousMetrics.longestRun)
                }
            ];

            tbody.innerHTML = rows.map(row => `
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <td style="padding: 12px; color: #ffffff;">${row.metric}</td>
                    <td style="padding: 12px; text-align: center; color: #ffffff;">${row.previous}</td>
                    <td style="padding: 12px; text-align: center; color: #ffffff;">${row.current}</td>
                    <td style="padding: 12px; text-align: center; color: #ffffff;">${row.change}</td>
                </tr>
            `).join('');
        }

        function updateRunningRecords(allRuns) {
            const recordsDiv = document.getElementById('runningRecords');
            if (!recordsDiv) return;

            const records = findRunningRecords(allRuns);
            
            recordsDiv.innerHTML = records.map(record => `
                <div class="record-item">
                    <div>
                        <strong>${record.type}</strong>
                        <div style="font-size: 0.9rem; color: #6B7280;">
                            ${record.value} ‚Ä¢ ${record.date}
                        </div>
                    </div>
                    ${record.isNew ? '<span class="record-badge">NEW!</span>' : ''}
                </div>
            `).join('');
        }

        function updateRunningEnduranceChart(runs) {
            if (!charts.runningEndurance) {
                charts.runningEndurance = new Chart(document.getElementById('runningEnduranceChart'), {
                    type: 'bar',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Distance (km)' }
                            }
                        }
                    }
                });
            }

            // Group by week and find longest run per week
            const weeklyLongest = {};
            runs.forEach(run => {
                const weekStart = getWeekStart(new Date(run.start_date));
                const weekKey = weekStart.toISOString().split('T')[0];
                const distance = run.distance / 1000;
                
                if (!weeklyLongest[weekKey] || distance > weeklyLongest[weekKey]) {
                    weeklyLongest[weekKey] = distance;
                }
            });

            const weeks = Object.keys(weeklyLongest).sort();
            const distances = weeks.map(week => weeklyLongest[week]);

            charts.runningEndurance.data = {
                labels: weeks.map(w => new Date(w).toLocaleDateString()),
                datasets: [{
                    label: 'Longest Run',
                    data: distances,
                    backgroundColor: distances.map((d, i) => {
                        // Highlight new longest runs
                        if (i > 0 && d > Math.max(...distances.slice(0, i))) {
                            return '#10b981'; // Green for new record
                        }
                        return '#667eea';
                    })
                }]
            };

            charts.runningEndurance.update();
        }

        function generateRunningInsights(recentRuns, previousRuns) {
            const insights = [];
            
            // Load change insight
            const currentLoad = recentRuns.reduce((sum, r) => sum + (r.suffer_score || 0), 0);
            const previousLoad = previousRuns.reduce((sum, r) => sum + (r.suffer_score || 0), 0);
            const loadChange = previousLoad > 0 ? ((currentLoad - previousLoad) / previousLoad) * 100 : 0;
            
            if (loadChange > 20) {
                document.getElementById('runningLoadInsight').innerHTML = `
                    <h4>üìà Increased Training Load</h4>
                    <p>Your training load is up ${Math.round(loadChange)}% from the previous 4 weeks. Ensure adequate recovery between hard sessions.</p>
                `;
            } else if (loadChange < -20) {
                document.getElementById('runningLoadInsight').innerHTML = `
                    <h4>üìâ Reduced Training Load</h4>
                    <p>Your training load is down ${Math.abs(Math.round(loadChange))}%. This could be good for recovery or you might want to gradually increase volume.</p>
                `;
            }

            // Pace improvement insight
            const currentMetrics = calculateRunMetrics(recentRuns);
            const previousMetrics = calculateRunMetrics(previousRuns);
            
            if (currentMetrics.avgPace < previousMetrics.avgPace && currentMetrics.avgHR < previousMetrics.avgHR) {
                document.getElementById('runningPaceInsight').innerHTML = `
                    <h4>üöÄ Fitness Improvement Detected</h4>
                    <p>Your pace is improving while heart rate is dropping - a clear sign of enhanced running economy!</p>
                `;
            }

            // Endurance insight
            const longestRecent = Math.max(...recentRuns.map(r => r.distance / 1000));
            const longestPrevious = previousRuns.length > 0 ? Math.max(...previousRuns.map(r => r.distance / 1000)) : 0;
            
            if (longestRecent > longestPrevious * 1.2) {
                let percentageIncrease;
                let message;

                if (longestPrevious === 0) {
                    // First long run - no previous data to compare
                    message = `You completed your longest run of ${longestRecent.toFixed(1)}km! Great start to building your endurance base.`;
                } else {
                    // Normal percentage calculation
                    percentageIncrease = Math.round((longestRecent - longestPrevious) / longestPrevious * 100);
                    message = `Your longest run increased by ${percentageIncrease}%! Your endurance base is expanding.`;
                }

                document.getElementById('runningEnduranceInsight').innerHTML = `
                    <h4>üí™ Endurance Breakthrough</h4>
                    <p>${message}</p>
                `;
            }
        }

        // Helper functions
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }

        function calculateRunMetrics(runs) {
            if (runs.length === 0) {
                return {
                    avgDistance: 0,
                    weeklyRuns: 0,
                    avgPace: 0,
                    longestRun: 0,
                    avgHR: 0
                };
            }

            const totalDistance = runs.reduce((sum, r) => sum + (r.distance || 0), 0) / 1000;
            const avgDistance = totalDistance / runs.length;
            const weeklyRuns = runs.length / 4;
            
            const paces = runs.map(r => r.distance > 0 ? (r.moving_time / 60) / (r.distance / 1000) : 0)
                .filter(p => p > 0 && p < 10);
            const avgPace = paces.length > 0 ? paces.reduce((a, b) => a + b) / paces.length : 0;
            
            const longestRun = Math.max(...runs.map(r => r.distance / 1000));
            
            const hrs = runs.map(r => r.average_heartrate || 0).filter(hr => hr > 0);
            const avgHR = hrs.length > 0 ? hrs.reduce((a, b) => a + b) / hrs.length : 0;

            return { avgDistance, weeklyRuns, avgPace, longestRun, avgHR };
        }

        function formatPace(paceMinPerKm) {
            if (paceMinPerKm === 0) return '--';
            const minutes = Math.floor(paceMinPerKm);
            const seconds = Math.round((paceMinPerKm - minutes) * 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}/km`;
        }

        function calculateChange(current, previous, reverse = false) {
            if (previous === 0) return 'üÜï';
            const change = ((current - previous) / previous) * 100;
            const actualChange = reverse ? -change : change;
            
            if (Math.abs(actualChange) < 1) return '‚Üí';
            
            const arrow = actualChange > 0 ? 'üîº' : 'üîΩ';
            const color = actualChange > 0 ? '#10b981' : '#dc2626';
            return `<span style="color: ${color}">${arrow} ${Math.abs(Math.round(actualChange))}%</span>`;
        }

        function findRunningRecords(allRuns) {
            const records = [];
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            
            // Find fastest runs by common distances
            const distanceRecords = {
                '1K': { min: 950, max: 1050 },
                '5K': { min: 4900, max: 5100 },
                '10K': { min: 9900, max: 10100 },
                'Half Marathon': { min: 21000, max: 21200 },
                'Marathon': { min: 42000, max: 42300 }
            };

            Object.entries(distanceRecords).forEach(([distance, range]) => {
                const qualifyingRuns = allRuns.filter(r => 
                    r.distance >= range.min && r.distance <= range.max
                );
                
                if (qualifyingRuns.length > 0) {
                    const fastest = qualifyingRuns.reduce((best, run) => 
                        run.moving_time < best.moving_time ? run : best
                    );
                    
                    records.push({
                        type: `Fastest ${distance}`,
                        value: formatTime(fastest.moving_time),
                        date: new Date(fastest.start_date).toLocaleDateString(),
                        isNew: new Date(fastest.start_date) >= thirtyDaysAgo
                    });
                }
            });

            // Longest run
            const longestRun = allRuns.reduce((longest, run) => 
                run.distance > longest.distance ? run : longest
            , allRuns[0] || { distance: 0 });

            if (longestRun.distance > 0) {
                records.push({
                    type: 'Longest Run',
                    value: `${(longestRun.distance / 1000).toFixed(1)}km`,
                    date: new Date(longestRun.start_date).toLocaleDateString(),
                    isNew: new Date(longestRun.start_date) >= thirtyDaysAgo
                });
            }

            return records;
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function showEmptyRunningState() {
            document.getElementById('runningDistance').textContent = '--';
            document.getElementById('runningFrequency').textContent = '--';
            document.getElementById('runningDuration').textContent = '--';
            document.getElementById('runningElevation').textContent = '--';
            
            const emptyMessage = '<div style="text-align: center; padding: 20px; color: #6B7280;">Connect Strava to see your running analytics</div>';
            
            document.getElementById('runningLoadInsight').innerHTML = emptyMessage;
            document.getElementById('runningPaceInsight').innerHTML = emptyMessage;
            document.getElementById('runningEnduranceInsight').innerHTML = emptyMessage;
            document.getElementById('runningProgressBody').innerHTML = `<tr><td colspan="4" style="text-align: center; padding: 20px; color: #6B7280;">No running data available</td></tr>`;
            document.getElementById('runningRecords').innerHTML = emptyMessage;
        }

        // Tab event listeners initialized in main DOMContentLoaded below (line ~4280)

        async function clearAllData() {
            if (confirm('Clear all connected device data? You\'ll need to reconnect each service.')) {
                // Delete tokens from backend database
                const userId = localStorage.getItem('userId');
                if (userId) {
                    try {
                        const providers = ['strava', 'oura', 'garmin', 'whoop'];
                        for (const provider of providers) {
                            await fetch(`${API_CONFIG.backend}/api/sync/delete-token`, {
                                method: 'DELETE',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ userId, provider })
                            }).catch(err => console.warn(`Failed to delete ${provider} token:`, err));
                        }
                    } catch (error) {
                        console.error('Error deleting tokens from database:', error);
                    }
                }

                fitnessData = {
                    strava: null,
                    oura: null,
                    whoop: null,
                    garmin: null,
                    lastUpdated: null
                };

                localStorage.removeItem('strava_token');
                localStorage.removeItem('strava_expiry');
                localStorage.removeItem('oura_token');
                localStorage.removeItem('oura_expiry');
                localStorage.removeItem('garmin_token');
                localStorage.removeItem('garmin_expiry');
                localStorage.removeItem('garmin_refresh_token');
                localStorage.removeItem('whoop_token');
                localStorage.removeItem('whoop_expiry');
                localStorage.removeItem('whoop_refresh_token');

                // Clear sessionStorage OAuth data as well
                if (typeof sessionStorage !== 'undefined') {
                    sessionStorage.removeItem('garmin_oauth_state');
                    sessionStorage.removeItem('garmin_code_verifier');
                    sessionStorage.removeItem('whoop_oauth_state');
                    sessionStorage.removeItem('whoop_code_verifier');
                }

                document.querySelector('.btn-strava').innerHTML = 'Connect Strava';
                document.querySelector('.btn-oura').innerHTML = 'Connect Oura';
                document.querySelector('.btn-garmin').innerHTML = 'Connect Garmin';
                document.querySelector('.btn-whoop').innerHTML = 'Connect Whoop';

                document.querySelectorAll('.connect-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('connected');
                });

                updateConnectionStatus();
                showMessage('All data cleared. Ready to reconnect devices.', 'info');
            }
        }

        async function refreshAllData() {
            showMessage('Refreshing all connected data...', 'info');

            const stravaToken = localStorage.getItem('strava_token');
            const ouraToken = localStorage.getItem('oura_token');
            const whoopToken = localStorage.getItem('whoop_token');
            const garminToken = localStorage.getItem('garmin_token');

            const refreshPromises = [];

            if (stravaToken) {
                refreshPromises.push(fetchStravaData(stravaToken));
            }

            if (ouraToken) {
                refreshPromises.push(fetchOuraData(ouraToken));
            }

            if (whoopToken) {
                refreshPromises.push(fetchWhoopData(whoopToken));
            }

            if (garminToken) {
                refreshPromises.push(fetchGarminData(garminToken));
            }

            if (refreshPromises.length === 0) {
                showMessage('No connected devices to refresh', 'warning');
                return;
            }

            try {
                await Promise.all(refreshPromises);
                showMessage('All data refreshed successfully!', 'success');
            } catch (error) {
                showMessage('Some data failed to refresh', 'warning');
                console.error('Refresh error:', error);
            }
        }

        function showMessage(message, type = 'info') {
            // On mobile, skip connection success messages to avoid distraction
            const isMobile = window.innerWidth <= 768;
            if (isMobile && type === 'success' && message.toLowerCase().includes('connect')) {
                console.log('üì± Mobile: Skipping connection alert:', message);
                return; // Don't show connection alerts on mobile
            }

            const messageDiv = document.createElement('div');
            const colors = {
                success: 'rgba(16, 185, 129, 0.1)',
                error: 'rgba(220, 38, 38, 0.15)',
                warning: 'rgba(245, 158, 11, 0.1)',
                info: 'rgba(59, 130, 246, 0.1)'
            };

            const borderColors = {
                success: 'rgba(16, 185, 129, 0.2)',
                error: 'rgba(220, 38, 38, 0.25)',
                warning: 'rgba(245, 158, 11, 0.2)',
                info: 'rgba(59, 130, 246, 0.2)'
            };

            // Count existing messages to stack them
            const existingMessages = document.querySelectorAll('.status-message');
            const offset = existingMessages.length * (isMobile ? 20 : 28);

            messageDiv.className = 'status-message';

            if (isMobile) {
                // Mobile: very subtle, small toast
                messageDiv.style.cssText = `
                    position: fixed;
                    bottom: ${120 + offset}px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: ${colors[type]};
                    backdrop-filter: blur(6px);
                    -webkit-backdrop-filter: blur(6px);
                    color: rgba(255, 255, 255, 0.85);
                    padding: 5px 10px;
                    border-radius: 6px;
                    border: 1px solid ${borderColors[type]};
                    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
                    z-index: 998;
                    max-width: 180px;
                    font-size: 0.65rem;
                    font-weight: 400;
                    transition: opacity 0.2s ease;
                    opacity: 0;
                    pointer-events: none;
                    text-align: center;
                `;
            } else {
                // Desktop: bottom-left as before
                messageDiv.style.cssText = `
                    position: fixed;
                    bottom: ${80 + offset}px;
                    left: 20px;
                    background: ${colors[type]};
                    backdrop-filter: blur(8px);
                    -webkit-backdrop-filter: blur(8px);
                    color: rgba(255, 255, 255, 0.7);
                    padding: 4px 10px;
                    border-radius: 4px;
                    border: 1px solid ${borderColors[type]};
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    z-index: 1000;
                    max-width: 220px;
                    font-size: 0.65rem;
                    font-weight: 400;
                    transition: opacity 0.3s ease;
                    opacity: 0.5;
                    pointer-events: none;
                `;
            }

            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            // Fade in - very subtle on mobile
            setTimeout(() => messageDiv.style.opacity = isMobile ? '0.65' : '0.6', 10);

            // Fade out and remove - much faster on mobile
            const fadeOutTime = isMobile ? 1200 : 1800;
            const removeTime = isMobile ? 1500 : 2200;
            setTimeout(() => messageDiv.style.opacity = '0', fadeOutTime);
            setTimeout(() => messageDiv.remove(), removeTime);
        }

        // ===== CHART INITIALIZATION =====
        function initializeCharts() {
            try {
                // Check if Chart.js is available
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js not loaded');
                    return;
                }

                const chartOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                };

                // Initialize only the charts that exist in the HTML
                charts.scoreTrend = new Chart(document.getElementById('scoreTrendChart'), {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: { ...chartOptions }
            });

            charts.scoreBreakdown = new Chart(document.getElementById('scoreBreakdownChart'), {
                type: 'bar',
                data: { labels: [], datasets: [] },
                options: { ...chartOptions }
            });

            charts.stravaLoad = new Chart(document.getElementById('stravaLoadChart'), {
                type: 'bar',
                data: { labels: [], datasets: [] },
                options: { ...chartOptions }
            });

            charts.ouraSleepStages = new Chart(document.getElementById('ouraSleepStagesChart'), {
                type: 'bar',
                data: { labels: [], datasets: [] },
                options: { 
                    ...chartOptions, 
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { stacked: true },
                        y: { stacked: true, title: { display: true, text: 'Hours' } }
                    }
                }
            });

            charts.ouraCorrelation = new Chart(document.getElementById('ouraCorrelationChart'), {
                type: 'scatter',
                data: { datasets: [] },
                options: { 
                    ...chartOptions,
                    plugins: { legend: { display: true }, tooltip: { callbacks: { label: ctx => `HRV ${ctx.parsed.x} ms, Readiness ${ctx.parsed.y}` } } }
                }
            });

            charts.whoopTrend = new Chart(document.getElementById('whoopTrendChart'), {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    ...chartOptions,
                    plugins: { legend: { display: true } },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: { display: true, text: 'Score (%)' }
                        }
                    }
                }
            });

            // Additional charts if present
            if (document.getElementById('ouraTrendRS')) {
                charts.ouraTrendRS = new Chart(document.getElementById('ouraTrendRS'), {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: { 
                        ...chartOptions,
                        plugins: { legend: { display: true } },
                        scales: { y: { min: 0, max: 100, title: { display: true, text: 'Score' } } }
                    }
                });
            }
            if (document.getElementById('ouraTrendHRVHR')) {
                charts.ouraTrendHRVHR = new Chart(document.getElementById('ouraTrendHRVHR'), {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: { 
                        ...chartOptions,
                        plugins: { legend: { display: true } },
                        scales: { y: { title: { display: true, text: 'HR / HRV' } } }
                    }
                });
            }
            if (document.getElementById('whoopRecoveryTrendChart')) {
                charts.whoopRecoveryTrend = new Chart(document.getElementById('whoopRecoveryTrendChart'), {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: { 
                        ...chartOptions,
                        plugins: { legend: { display: true } },
                        scales: { y: { min: 0, max: 100, title: { display: true, text: 'Recovery %' } } }
                    }
                });
            }
            if (document.getElementById('stravaIntensityDistChart')) {
                charts.stravaIntensityDist = new Chart(document.getElementById('stravaIntensityDistChart'), {
                    type: 'bar',
                    data: { labels: ['Very Easy','Easy','Moderate','Hard','Very Hard'], datasets: [{ data: [], backgroundColor: ['#93c5fd','#60a5fa','#3b82f6','#2563eb','#1d4ed8'] }] },
                    options: { 
                        ...chartOptions,
                        plugins: { legend: { display: false } },
                        scales: { y: { title: { display: true, text: 'Minutes' } } }
                    }
                });
            }
            } catch (error) {
                console.error('Chart initialization failed:', error);
            }
        }
        
        // Tab switching function - SIMPLIFIED
        function switchTab(tabName, clickedButton) {
            console.log('=== SWITCH TAB START ===', tabName);

            // Hide all panels
            const allPanels = document.querySelectorAll('.tab-panel');
            allPanels.forEach(panel => {
                panel.classList.remove('active');
                console.log('Hiding:', panel.id);
            });

            // Deactivate all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show target panel
            const targetPanel = document.getElementById(tabName);
            if (targetPanel) {
                targetPanel.classList.add('active');
                console.log('Showing:', tabName, 'has active class:', targetPanel.classList.contains('active'));

                // Activate button
                if (clickedButton) {
                    clickedButton.classList.add('active');
                }

                // Trigger updates
                if (['overview', 'strava', 'oura', 'garmin', 'whoop', 'insights'].includes(tabName)) {
                    if (typeof updateAnalytics === 'function') updateAnalytics();
                }
                if (tabName === 'running' && typeof updateRunningAnalytics === 'function') {
                    updateRunningAnalytics();
                }
                if (tabName === 'garmin') {
                    console.log('üî• Garmin tab detected, typeof updateGarminDisplay:', typeof updateGarminDisplay);
                    if (typeof updateGarminDisplay === 'function') {
                        console.log('üî• Calling updateGarminDisplay NOW!');
                        updateGarminDisplay();
                    } else {
                        console.log('‚ùå updateGarminDisplay is not a function!');
                    }
                }
            }
            console.log('=== SWITCH TAB END ===');
        }

        // Tab scroll indicators for mobile
        function updateTabScrollIndicators() {
            const tabNav = document.getElementById('tabNav');
            const leftIndicator = document.getElementById('tabScrollLeft');
            const rightIndicator = document.getElementById('tabScrollRight');

            if (!tabNav || !leftIndicator || !rightIndicator) return;

            // Only show on mobile when content is scrollable
            const isMobile = window.innerWidth < 768;
            const isScrollable = tabNav.scrollWidth > tabNav.clientWidth;

            if (!isMobile || !isScrollable) {
                leftIndicator.classList.remove('visible');
                rightIndicator.classList.remove('visible');
                return;
            }

            const scrollLeft = tabNav.scrollLeft;
            const maxScroll = tabNav.scrollWidth - tabNav.clientWidth;

            // Show left arrow if not at start
            if (scrollLeft > 10) {
                leftIndicator.classList.add('visible');
            } else {
                leftIndicator.classList.remove('visible');
            }

            // Show right arrow if not at end
            if (scrollLeft < maxScroll - 10) {
                rightIndicator.classList.add('visible');
            } else {
                rightIndicator.classList.remove('visible');
            }
        }

        // Set correlation window selector and re-generate insights on change
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize tab event listeners
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    const tabName = this.getAttribute('data-tab');
                    if (tabName) {
                        switchTab(tabName, this);
                    }
                });
            });

            // Initialize tab scroll indicators
            const tabNav = document.getElementById('tabNav');
            if (tabNav) {
                tabNav.addEventListener('scroll', updateTabScrollIndicators);
                window.addEventListener('resize', updateTabScrollIndicators);
                // Initial check
                setTimeout(updateTabScrollIndicators, 100);
            }

            const sel = document.getElementById('correlationWindow');
            if (sel) {
                sel.value = String(getInsightWindowDays());
                sel.addEventListener('change', (e) => {
                    const v = parseInt(e.target.value, 10);
                    localStorage.setItem('insight_window_days', String(v));
                    generateAIInsights();
                });
            }

            // Removed dummy Garmin data - using real data only

            // Contact form handler
            const contactForm = document.getElementById('contactForm');
            if (contactForm) {
                contactForm.addEventListener('submit', async (e) => {
                    e.preventDefault();

                    const statusDiv = document.getElementById('contactFormStatus');
                    const submitButton = contactForm.querySelector('button[type="submit"]');

                    // Get form data
                    const formData = {
                        name: document.getElementById('contactName').value.trim(),
                        email: document.getElementById('contactEmail').value.trim(),
                        subject: document.getElementById('contactSubject').value.trim(),
                        message: document.getElementById('contactMessage').value.trim()
                    };

                    // Disable submit button
                    submitButton.disabled = true;
                    submitButton.textContent = 'Sending...';

                    try {
                        const response = await fetch('/api/contact', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(formData)
                        });

                        const data = await response.json();

                        if (response.ok) {
                            // Success
                            statusDiv.style.display = 'block';
                            statusDiv.style.background = 'rgba(16, 185, 129, 0.2)';
                            statusDiv.style.border = '1px solid rgba(16, 185, 129, 0.4)';
                            statusDiv.style.color = 'rgba(255, 255, 255, 0.95)';
                            statusDiv.textContent = data.message;

                            // Clear form
                            contactForm.reset();
                        } else {
                            // Error
                            throw new Error(data.message || 'Failed to send message');
                        }
                    } catch (error) {
                        console.error('Contact form error:', error);
                        statusDiv.style.display = 'block';
                        statusDiv.style.background = 'rgba(220, 38, 38, 0.2)';
                        statusDiv.style.border = '1px solid rgba(220, 38, 38, 0.4)';
                        statusDiv.style.color = 'rgba(255, 255, 255, 0.95)';
                        statusDiv.textContent = error.message || 'Failed to send message. Please try again or email us directly at info@athlytx.com';
                    } finally {
                        // Re-enable submit button
                        submitButton.disabled = false;
                        submitButton.textContent = 'Send Message';

                        // Hide status after 5 seconds
                        setTimeout(() => {
                            statusDiv.style.display = 'none';
                        }, 5000);
                    }
                });
            }
        });
    </script>

    <!-- OAuth Integration Scripts -->
    <script src="garmin-oauth2.js"></script>
    <script src="whoop-oauth2.js"></script>
    <script src="oauth-handler.js"></script>
    <script src="micro-interactions.js"></script>
</body>
</html>
